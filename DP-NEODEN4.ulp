#usage "Generate a CSV file suitable for Neoden 4 Pick n Place software V4.1.3 B9\n"
"Created by Dangerous Prototypes.com\n"
"Ian Lesnet (Feb. 18, 2013)\n"
"Parts of the code from Xinort\n"
"Modified with GUI enhancement by Jamz\n"
"Neoden 4 charliex@nullspacelabs.com\n"
"1.0j\n"
// -----------------------
int debug = 0;                   // set to one for debug: show variables 2 for more
string VERSION = "1.0j";

//------------------------------------Variables ---------------------------------------------------//

// modify these two variables accordingly

int LinesPerTab = 24;            // limit lines per tab. if lines are more than this make a new tab
int MAXREEL = 98;                // 16 Reels for tm220a, 24 for tm240 (untested), 98 for Neoden4, 99 is considered unused
int REELS_PER_PAGE = 14;        // reels shown per page
int SPECIALREEL = 49;			// in the neoden4 49 and up are special reels.

int tabloop;
int AddTab = 0;
string pcb_layers[];
int YES = 1;
int NO = 0;
int found;
int counter = 0;                // use to know how many parts (elements) are there in the board, including Logo,name etc
int Result = 0;
string SourceFname = "";        // file name of current board
string StackFname;              // Stack configuration filename
string workdir;                 // file save directory
string csvnametop = "";         // CSV file Top
string csvnamebottom = "";      // CSV file Bottom
string UserStackFname = "";     // User defined Standard Stack
real Xorigin = 0.00;
real Yorigin = 0.00;
int line = 1;

int Selected = 0;

// amount to offset the board by
real board_offset_x = 0;
real board_offset_y = 0;

// override move speed
int board_move_override = 100;

// if you already know the rotation, note the neoden UI rounds the value, the csv has the floating point representation
real g_board_rotation = 0;


int i, j, k, l, m, n = 0;       //general purpose iteration/index variable
// --------------------------------------------Display clickable Picture, linked to DP ------------------------------------------
string Text = "<br><br><center><a href='http://dangerousprototypes.com/2013/02/21/workshop-video-56-tm220a-table-top-pick-and-place-overview/'>Dangerous Prototypes Original Post</A><BR>"
              "<br><center><a href='https://www.nullspacelabs.com'>NullSpaceLabs.com</A>"
              "<br><center><a href='https://www.github.com/charlie-x'>Github Link</A>"

              ; // image showed a 404

string Help1 = "<p><strong>Reel Name</strong> - Enter the Your Assigned name to the Reel, <strong>Reel Footprint</strong> - Footprint of part"
               "<br><strong>Height</strong> - Enter the Height for the Reel. Valid values are 0.00 to 5.00."
               "<br><strong>Feeding Rate</strong> - Enter Feeding Rate. Valid values are 0 to 20."
               "<br><strong>Rotation Correction</strong> - If Parts' placement rotation is off, select rotation value to add. a <strong>180</strong> degree rotation rotates the reel's part by .</p>";
string Help2 = "<p><strong>NullSpaceLabs.com's Standard Stack</strong> - This button loads the NullSpaceLabs.com' Standard Stack><BR><strong>Load User's Standard Stack</strong> - Load a predefined stack <strong>Save User's Standard Stack</strong> - Save a stack for loading later<BR>"
               "<br><strong>Accept</strong> - Accept the displayed values. <strong>Cancel</strong> - Reject the changed values. "
               "<br>If there are reel assignments under the tabs<strong> PCB Top</strong> and<strong> PCB Bottom</strong>, it will be updated, as well as the values  in <strong>Height</strong> and <strong>Rate</strong>.</p>"
               "<p>Reels with 0,0 Pick XY, blank eel Name (or a single space) will not be exported";


// DP's Common Parts offset use '|' as separator
//Package|x|y|Comment
string DP_Packages[] = {"0402|0.00|0.05|0402",
                        "0603|-0.40|-0.10|0603",
                        "0805|0.05|0.00|0805",
                        "1206|0.23|0.00|1206",
                        "EOL|0.00|0.00|EOL"
                       };       // EOL - End of line indicator

// example neoden 4 feeder csv - tested with Neoden software V4.1.3 B9

// Nozzle can be a list so if its 1, its 1, if its 1 and 4, its 14, all would be 1234

//#Feeder, Feeder ID, Type, Nozzle, X, Y, Angle, Footprint, Value, Pick height, Pick delay, Placement height, Placement delay, Vacuum test, Vacuum value, Vision alignment, Speed, SkipSize testFlash typeLighting brightness, , , , ,
//stack,  5, 0, 34, 526.7 ,  0    ,     0, 1206, 1206,    0, 0,    0, 0, No, -40, 1, 100, No, No,  1, 50, 4, 100
//stack,  6, 0, 34, 506.5 ,  0    ,     0, 1206, 1206,    0, 0,    0, 0, No, -40, 1, 100, No, No,  1, 50, 4, 100
//stack, 11, 0, 12, 528.3 ,  0    ,     0, 1206, 1206,    0, 0,    0, 0, No, -40, 1, 100, No, No,  1, 50, 4, 100

//idstac ID TY  NZ  X       Y       PAng   Foot  Val              PHGT  PID PHT   PLD VD  VCV VA  SPD  FRT FST PST SKP SZ
///       0  1   2    3        4     5      6         7            8     9   10    11 12  13  14   15   16  17  18 19  20
//stack,  1, 0,   , 413.00,  90.00, -123.01, 0805, footprint / one, 0.50,  9, 0.00, 10, Yes, -40, 0, 100, 4, 50, 80, Yes, Yes,

// feeders 49+ are special, tray feeders in GUI but its 49+ in output file
//stack, 49, 1, 1, 400.00, 35.00, 0.00, , 49, 0.50, 0, 0.00, 0, No, -40, 1, 100, 1, 1, 400.00, 35.00, 1, 1, No, No,
//stack, 50, 1, 1, 400.00, 46.00, 0.00, , 50, 0.50, 0, 0.00, 0, No, -40, 1, 100, 1, 1, 400.00, 46.00, 1, 1, No, No,

//stack,  1, 0,  1, 413.00, 90.00 , 90.00, 0805,    1, 0.50, 9, 0.00, 10, No, -40, 1, 100,  4, 50, 80, Yes, Yes,
//stack,  2, 0,  1, 413.00, 103.00, 90.00, 0805,    2, 0.50, 0, 0.00,  0, No, -40, 1, 100,  4, 50, 80, No, No,
//stack,  3, 0,  1, 413.00, 116.00, 90.00, 1206,    3, 0.50, 0, 0.00,  0, No, -40, 1, 100,  4, 50, 80, No, No,

// Reel#|Size|Part|Package|height|rate|RotationCorrection:0=0,1=90,2=180,3=270|OffSetX|OffSetY
// Feeder ID, Type, Nozzle, X, Y, Angle, Footprint, Value, Pick height, Pick delay, Placement height,
// Placement delay, Vacuum test, Vacuum value, Vision alignment, Speed,
// SkipSize testFlash typeLighting brightness, , , , ,

//stack,98,1,1,92.27,226.88,0.00,0805,special/special,-1.00,0,0.00,0,No,-40,1,50,9,8,162.27,206.88,3,4,Yes,Yes,-40,-45,-50,-55,
//stack,98,1,1,92.27,226.88,0.00,0805,special/special,-1.00,0,0.00,0,No,-40,1,50,9,8,162.27,206.88,3,4, No,Yes,-40,-45,-50,-55,

///////////////////////////////////////////////
// normal feeder setup
//#Feeder,Feeder ID,Type,Nozzle, X,       Y,    Angle, Footprint, Value ,Pick height,Pick delay,Placement height,Placement delay,Vacuum detection,Vacuum value,Vision alignment,Speed,
//stack,       2,     0,  12,  409.87, 101.73, 90.00,  0805,       2.2nF,     0.50,       0,          0.50,             0,             No,            -40,            1,           50,

//continued (different to special feeders)
// Feed Rate, Feed torque,  Peel Strength,   skip,  size correct        Thresholds for nozzles 1-4
// 4,          80,            50,             No,        No,             -40, -40, -40, -40,

///////////////////////////////////////////////
//special feeders have a different format.

//#Feeder, Feeder ID, Type, Nozzle,    X,      Y, Angle, Footprint, Value  , Pick height, Pick delay, Place Height, Place Delay, Vacuum Discard,  Threshold, Vision Alignment, Speed,
//stack,   98,          1,    1 ,  92.27, 226.88, 0.00,     0805,   special,-1.00,            0,           0.00,         0,            No,            -40,       1,                50,

//continued, differences are here
// columns, rows, right top x , right top y, startx, starty,   skip, size correct,  thresholds for nozzles 1-4
// 9,        8,   162.27,      206.88,         3,       4,        No,      No,       -40,-40,-40,-40,

// you  can copy and paste a neoden4 stack in here, just add a " at the start and ", at the end, on the last line at the end use " instead of ",
// this will work with either , or | as a delimiter, stack 49 onwards are a different format to pre 49 reels.

// 1..98, order doesn't matter, can skip
string NSL_partList[] = {
    //stack 1,isn't here, starts from 1.
    "stack,2,0,123,409.87,101.73,90.00,0805,2.2nF,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,3,0,1,409.85,115.04,90.00,0805,10uF,0.50,0,1.00,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,4,0,1,409.95,128.58,90.00,0805,1.0uF,0.50,0,1.00,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,6,0,1,409.67,155.74,90.00,0805,22uF,0.50,0,1.00,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,7,0,1,409.52,168.95,90.00,0805,220pF,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,9,0,1,410.02,262.96,90.00,0805,2M,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,10,0,1,409.79,276.41,90.00,0805,2R,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,11,0,1,410.07,289.90,90.00,0805,100K,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,14,0,1,410.04,330.72,90.00,0805,1M,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,15,0,1,409.71,344.21,90.00,0805,470R,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,17,0,1,410.50,374.14,90.00,2512,0.01R,0.50,0,0.60,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,18,0,4,409.90,389.44,90.00,D/7434-21,100uF,0.50,0,2.30,0,No,-40,1,20,8,50,80,No,No,-40,-40,-40,-40,",
    "stack,21,0,1,23.04,37.43,-90.00,SOT23,0.1uF,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,22,0,1,23.24,51.09,-90.00,0805,2.2uF,0.50,0,1.00,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,27,0,1,23.29,119.48,-90.00,0805,4k7,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,28,0,1,24.15,132.82,-90.00,0805,27R,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,29,0,1,23.46,146.66,-90.00,0805,47pF,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,33,0,1,22.89,201.04,-90.00,0805,10K,0.50,0,0.50,0,No,-40,1,30,4,50,80,No,No,-40,-40,-40,-40,",
    "stack,39,0,2,23.92,283.60,-90.00,3535,LEDRGB,0.50,0,1.60,0,No,0,1,20,8,50,80,No,No,-40,-40,-40,-40,",
    "stack,41,0,1,23.82,320.50,-90.00,SRN6045TA-1R0Y,1uH,0.50,0,5.00,0,No,-40,1,30,8,50,80,No,No,-40,-40,-40,-40,",
    "stack,78,1,1,150.00,290.00,0.00,SOIC127P600X175-8N,LT1963ES8-3.3PBF,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,0.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,79,1,1,150.00,300.00,0.00,SC70-6,MBT3904DW1T1,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,0.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,80,1,1,150.00,310.00,0.00,,WS2812B,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,0.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,81,1,1,150.00,320.00,0.00,TSSOP29,PCM5100,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,0.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,82,1,1,150.00,330.00,0.00,TQFP44,CY8C4245,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,0.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,83,1,1,150.00,340.00,0.00,TPTP10R,TP10R,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,0.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,84,1,1,150.00,350.00,0.00,SPH0645LM4H,MIC_I2S_SPH0645,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,0.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,85,1,1,150.00,360.00,0.00,SOIC127P600X175-8N,IRF9358TRPBF,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,86,1,1,150.00,370.00,0.00,SOT23-5,M74VHC1GT125DF2G,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,87,1,1,150.00,380.00,0.00,SLOT,SLOT,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,88,1,1,150.00,390.00,0.00,SOIC127P600X170-9N,DIO7320,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,89,1,1,150.00,400.00,0.00,,SC70-6,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,90,1,1,132.64,217.56,0.00,QFN40P300X300X105-25N,MPU-9250,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,91,1,1,121.00,217.52,0.00,QFN24,IP5209,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,92,1,1,97.88,211.92,0.00,ESP-WROOM-32,ESP-WROOM-32,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,93,1,4,159.49,227.05,0.00,SPST_SMT_19192,BM06B-SRSS-TB,1.10,0,1.40,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,94,1,4,146.93,227.88,0.00,1206,LED RED,1.00,0,1.50,1,No,-40,1,20,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,95,1,1,134.39,227.57,0.00,24X16_RGB_LED5MM_RGB_EDGE,WS2812B,0.50,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,96,1,4,120.06,227.38,0.00,QFN20,FT231XQ,0.70,0,2.70,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,97,1,4,107.73,227.09,0.00,FIDUCIAL_1MM,FIDUCIAL,0.70,0,2.70,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,",
    "stack,98,1,1,92.27,226.88,0.00,0805,couple pf -DNP,-1.00,0,0.00,0,No,-40,1,30,1,1,80.00,1.00,1,1,No,No,-40,-40,-40,-40,"
};

int  DP_stack_Loaded = 0;    // flag 1 if dp stack is loaded

/// array for trays which are 49 and up
//struct {
int trayColumns[];
int trayRows[];
// coords
real trayRightTopX[];
real trayRightTopY[];
int trayStartX[];
int trayStartY[];
//}

// array for each individual parts as found in the pcb
//struct {
string Ename[];             // Parts name
string Evalue[];            // Parts value
string Epackagename[];       // Package
string ElibrarySource[];    // Library source
string EpartsX[];           // x coordinate
string EpartsY[];           // y coordinate
string Elayer[];            // layer - Top/Bottom
string Eangle[];               // angle of placement
int Efeeder[];
real Eheight[];
string Eheadline[];
int  Eptr[];                 //Line number, fills in number to track line an index ptr
// }


// Array to Hold for display by grouping
// struct {
int g_class[];                // Used to group parts use variable grouping
int g_ptr[];                 // pointer to array # of this structure
string g_Ename[];            //Parts name e.g. c1,c2,c3
string g_EnameTemp[];        // used temporarily to store first part
string g_Evalue[];           // parts value e.g 1uf
string g_Epackagename[];     // Package name like C0603
string g_ElibrarySource[];    // library
string g_EpartsX[];          // x coordinate of parts
string g_EpartsY[];          // y coordinate of parts
string g_Elayer[];           // PCB layer - Top, Bottom
int g_Head[];                // Head - 1 - 4 used by Neoden 4
real g_Eheight[];            // height of parts used bu tm220, set to 0 as default
int g_Equantity[];           // count of parts with same value
int g_Erate[];               // feeder Rate  used by tm220a ( 0,1,2 .. 20?)
string g_Eangle[];              // Angle of rotation of pats
int g_TapeSkip[];            // Tape skip  used by tm220a
int g_Efeeder[];             // hold feeder assignment, initially 99 for no assignment
string g_Eheadline[];
string g_backptr[];
// }
int grouping = 0;
int ReelNo_Top[];
int ReelNo_Bottom[];                      // Reel # 0 to 15
int index = 0;                    // counter for array the holds the group partlist
//struct {  // used after separting the top and bottom layer
int CT_ReelNo[];  // holds the reelno 0-15,99
string CT_EpartsX[];
string CT_EpartsY[];
string CT_Epackagename[];
string CT_Evalue[];
string CT_Elayer[];
real CT_Eheight[];
int CT_Ehead[];
int CT_Skip[];
int CT_Rate[];
int CT_class[];
string CT_backptr[];
// }

// struct {
int CB_ReelNo[];  // holds the reelno 0-15
string CB_EpartsX[];
string CB_EpartsY[];
string CB_Epackagename[];
string CB_Evalue[];
string CB_Elayer[];
real CB_Eheight[];
int CB_Ehead[];
int CB_Skip[];
int CB_Rate[];
int CB_class[];
string CB_backptr[];
// }

// struct {
int CM_ReelNo[];  // holds the reelno 0-15
string CM_EpartsX[];
string CM_EpartsY[];
string CM_Epackagename[];
string CM_Evalue[];
string CM_Elayer[];
real CM_Eheight[];
int CM_Ehead[];
int CM_Skip[];
int CM_Rate[];
int CM_class[];
string CM_backptr[];
// }
//struct {  // Top - variables f
int g_Efeeder_Top[];
int g_Head_Top[];
real g_Eheight_Top[];
int g_TapeSkip_Top[];
int g_Erate_Top[];
// }
//struct {   // bottom
int g_Efeeder_Bottom[];
int g_Head_Bottom[];
real g_Eheight_Bottom[];
int g_TapeSkip_Bottom[];
int g_Erate_Bottom[];
// }
//struct {   //Mid
int g_Efeeder_Mid[];
int g_Head_Mid[];
real g_Eheight_Mid[];
int g_TapeSkip_Mid[];
int g_Erate_Mid[];
// }

real BoardX = 0.00;               // size of pcb board in x axis  (lower left)
real BoardY = 0.00;              // size of pcb board in y axis  (lower left)
int nBoardsinX = 0;              // no. of boards in x direction
int nBoardsinY = 0;              // no. of Boards in Y direction
real GapBoardX = 0.00;           // gap between boards
real GapBoardY = 0.00;           // gap between boards

string components_Top[];         //  concatenation of variables for top layer: g_name+value+package use in combobox
string grp_components_Top[];     // group and format parts into c1-c10, instead of c1,c2,c3,c4c4 etc
string component_quantity_Top[]; // version 1 update - break components_Top
string component_value_Top[];
string component_packagename_Top[];

string components_Bottom[];      //  concatenation of variables for bottom: g_name+value+package use in combobox
string grp_components_Bottom[];     // group and format parts into c1-c10, instead of c1,c2,c3,c4c4 etc
string component_quantity_Bottom[];
string component_value_Bottom[];
string component_packagename_Bottom[];

string components_Mid[];     //  concatenation of variables for bottom: g_name+value+package use in combobox
string grp_components_Mid[];     // group and format parts into c1-c10, instead of c1,c2,c3,c4c4 etc
string component_quantity_Mid[];
string component_value_Mid[];
string component_packagename_Mid[];

int comboSelected_Top[], comboSelected_Bottom[], comboSelected_Mid[];            //  ptr to array of grouped components for above used as combobox selector

int components_Bottom_ptr[], components_Top_ptr[], components_Mid_ptr[]; //  will hold the pointer to the array for  components_Bottom[];


int TopCounter = 0, BottomCounter = 0, MidCounter = 0; // Top components counter and Bottom component Counter, + in between layers
int len;
string dummy_grouping;
string g_Ename_group[];    // storage for grouped partslist
string partslist[];
string partsX;
string partsY;
string partsRotation;
string layer;
string Reel[];    // user defined names for reels
string ReelNameAndFoot[];    // auto generated name for reel name and footprint

string ReelNum[];		// string version of reel index


// Feeder Basic Information
int ReelHead[];       // Nozzle index into NozzleCombo used for this reel 1,2,3,4 etc
real ReelOffSetX[];
real ReelOffSetY[];

real ReelHeight[];     // pick height
int ReelPickDelay[];        // pick delay
real ReelPlaceHeight[];        // place height
int ReelPlaceDelay[];        // place delay
int  ReelMoveSpeed[];           // feeder move speed
int  ReelVacuumDetection[];     // Vacuum detection, on/off
int ReelVacuumValue[];         // -10 to -100
real  ReelPickAngle[];           // feeder -180,-90,0,90,180
int  ReelVisionAlignment[];     // No Action, Indivudally, Jointly, Large component
int  ReelSkip[];                 // Skip, check on/off
int  ReelSizeCorrect[];         // Size correct
string ReelFootPrint[];           // Footprint of Feeder/reel
int FeedExchange[];                 // Feeder Exchange Feeder 1 to 58
// feed box information
int ReelPeelStrength[];              // peel strength 80
int ReelFeedStrength[];              // feed strength   10 to 100 in steps of 1
int ReelRate[];              // size to move feeder for one component 2-32

string RotationOffset[];    // 0,90,180,270 - adds angle

string FeedRates[]; // 0 - 100, steps of 10
int FeedRatesSelected[];   // 0-9

string ComboThresholds[] = { "-10", "-15", "-20", "-25", "-30", "-35", "-40", "-45", "-50", "-55", "-60", "-65", "-70", "-75", "-80", "-85", "-90", "-95", "-100"};

int Nozzle1Thresholds[] ; //-10 to -100 in steps of 5 (index to combobox)
int Nozzle2Thresholds[]; //-10 to -100 in steps of 5
int Nozzle3Thresholds[]; //-10 to -100 in steps of 5
int Nozzle4Thresholds[]; //-10 to -100 in steps of 5

int xmax = -2147483648;
int xmin = 2147483647;
int maxComboLen_Top = -1, maxComboLen_Bottom = -1, maxComboLen_Mid = -1;   // maximum lenght of string in the combobox

//list of nozzle combinations for the parts dropdown
string nozzleCombo[] = { "-",
                         "1", "2", "3", "4",
                         "12", "13", "14",
                         "22", "23", "24",
                         "34",
                         "123", "124",
                         "234",
                         "1234"
                       };

//-------------------------------------------------------------------------------------------------------


// converts from nozzle combo to a single nozzle
int convert_to_nozzle ( int noz_id )
{
    string newnoz = "";

    // first entry is empty
    if ( noz_id == 0 ) { return 0; }

    newnoz = nozzleCombo[noz_id];

    //terminate
    newnoz[1] = 0;


    return strtol ( newnoz );
}

//  convert num to string
string Num2Str ( int i )
{
    string str;
    sprintf ( str, "%d", i );
    return str;
}
//  convert real num to string

string Num2StrF ( real i )
{
    string str;
    sprintf ( str, "%.3f", i );
    return str;
}

//trim leading and trailing spaces

string alltrim ( string s )
{
    while ( s && isspace ( s[0] ) ) {
        s = strsub ( s, 1 );
    }

    while ( s && isspace ( s[strlen ( s ) - 1] ) ) {
        s = strsub ( s, 0, strlen ( s ) - 1 );
    }

    if ( strlen ( s ) == 0 ) { s = " "; }

    return s;
}

string pad_all ( string text, int size, string chr )
{
    int len = strlen ( text );
    int lr = ( size - len ) / 2;
    int z;
    string ret;
    string xl;

    for ( z = 0; z < lr; z++ ) {
        xl += chr;
    }

    ret = xl + text + xl;
    return ret;
}

// determine if its a viable part to PNP
// NOPNP attribute for parts you don't want to include
// DNP for do not place
// if thru hole, skip
// if a testpad or jumper, skip

int skip_part ( UL_ELEMENT E )
{
    // Do Not place
    if ( E.value == "dnp" || E.value == "DNP" )
    { return 0; }

    // Zero Ohm jumpers ( 0 OHM resistors usually )
    if ( E.value == "zeroohm" )
    { return 0; }

    // Ignore Test PADS
    if ( !strstr ( E.value, "TESTPAD" ) )
    { return 0; }

    if ( E.value == "" )
    { return 0; }

    // Ignore Stand Offs
    if ( !strstr ( E.value, "STAND-OFF" ) )
    { return 0; }

    if ( !strstr ( E.value, "STANDOFF" ) )
    { return 0; }

    // Jumpers
    if ( !strstr ( E.value, "JUMPER" ) )
    { return 0; }

    // Specifically set no to PNP
    if ( E.attribute["NOPNP"] )
    { return 0; }


    // determine
    E.package.contacts ( C ) {

        // has pads?
        if ( C.pad  ) {
            return 0;
        }


        // no smds?
        if ( !C.smd ) {
            return 0;
        }
    }

    return 1;
}

// get X pos in mm of first part that will be output
real get_first_x()
{
    board ( B ) {
        B.elements ( E ) {
            // try to get the first part to be placed
            if ( skip_part ( E ) == 1 ) {
                return u2mm ( E.x ) ;
            }
        }
    }
    return -1;
}

// get Y pos in mm of first part that will be output
real get_first_y()
{
    board ( B ) {
        B.elements ( E ) {
            // try to get the first part to be placed
            if ( skip_part ( E ) == 1 ) {
                return u2mm ( E.y ) ;
            }
        }
    }
    return -1;
}

// check to see if its a fiducial, maybe we should test something longer
int is_fiducial ( UL_ELEMENT E )
{

    // does name contain FID
    if ( strstr ( E.value, "FID" ) >= 0 ) {
        return 1;
    }

    // does value contain FID
    if ( strstr ( E.name, "FID" ) >= 0  ) {
        return 1;
    }

    // we don't think its a fiducial
    return 0;
}

int round_and_clamp ( real value, real lower, real upper )
{
    //round it, the neoden will override anything that isn't in steps of 10 for some values
    value /= 10;
    value = round ( value ) * 10;

    // clamp it, set a minimum value
    if ( value < lower ) {
        value = lower;
    }

    // clamp it, set an upper
    if ( value > upper ) {
        value = upper;
    }

    return value;
}

// number of fiducials found
int g_fiducial_count = 0;

// XY list of fiducials found, in eagle space
real g_fiducial_x[];
real g_fiducial_y[];


// return number of fiducials found and add them to a list
int scan_for_fiducials()
{

    int fiducial_count = 0;

    board ( B ) {
        B.elements ( E ) {
            // find a fiducial
            if ( is_fiducial ( E ) == 1 ) {

                // remember it
                g_fiducial_x[fiducial_count] = u2mm ( E.x );
                g_fiducial_y[fiducial_count] = u2mm ( E.y );

                fiducial_count++;
            }

        }
    }
    // store it for later
    g_fiducial_count = fiducial_count;

    // send back count
    return fiducial_count;
}


//"stack,2,0,1,409.87,101.73,90.00,0805,0805/2.2nF,0.50,0,0.50,0,No,-40,1,100,4,50,80,No,No,-40,-40,-40,-40,",
//[REEL]|1|0805/2.2nF|0805|1|409.87|101.73|90.00|0805|0.50|0|0.50|0|NO|-40|1|100|4|50|80|NO|NO

// writes out a neoden 4 style string for a REEL
void write_reel_line ( int j )
{
    string str;

    // ReelHead/nozzle is now an index into the nozzleCombo

    if ( j < SPECIALREEL ) {


        ///////////////////////////////////////////////
        // normal feeder setup
        //#Feeder,Feeder ID,Type,Nozzle, X,       Y,    Angle, Footprint, Value ,Pick height,Pick delay,Placement height,Placement delay,Vacuum detection,Vacuum value,Vision alignment,Speed,
        //stack,       2,     0,  12,  409.87, 101.73, 90.00,  0805,       2.2nF,     0.50,       0,          0.50,             0,             No,            -40,            1,           50,

        //continued (different to special feeders)
        // Feed Rate, Feed torque,  Peel Strength,   skip,  size correct        Thresholds for nozzles 1-4
        // 4,          80,            50,             No,        No,             -40, -40, -40, -40,


        sprintf ( str, "[REEL]|%d|%d|%d|%.2f|%.2f|%.2f|%s|%s|%.2f|%d|%.2f|%d|%s|%d|%d|%d|%d|%d|%d|%s|%s|%d|%d|%d|%d\n",
                  j,									//%d 1
                  0,									//%d 2
                  ReelHead[j],							//%d 3
                  ReelOffSetX[j],						//%.2f 4
                  ReelOffSetY[j],						//%.2f 5
                  ReelPickAngle[j],						//%.2f 6
                  ReelFootPrint[j],						//%s 7
                  Reel[j],								//%s 8
                  ReelHeight[j],						//%.2f
                  ReelPickDelay[j],						//%d
                  ReelPlaceHeight[j],					//%.2f
                  ReelPlaceDelay[j],					//%d
                  ReelVacuumDetection[j] ? "YES" : "NO",//%s
                  ReelVacuumValue[j],					//%d
                  ReelVisionAlignment[j],				//%d
                  ReelMoveSpeed[j],						//%d

                  // changes here
                  ReelRate[j],							//%d
                  ReelFeedStrength[j],					//%d
                  ReelPeelStrength[j],					//%d
                  ReelSkip[j] ? "YES" : "NO",			//%s
                  ReelSizeCorrect[j] ? "YES" : "NO",	//%s

//thresholds
                  Nozzle1Thresholds[j], //%d
                  Nozzle2Thresholds[j], //%d
                  Nozzle3Thresholds[j], //%d
                  Nozzle4Thresholds[j] //%d
                );

    } else {

///////////////////////////////////////////////
//special feeders have a different format.

//#Feeder, Feeder ID, Type, Nozzle,    X,      Y, Angle, Footprint, Value  , Pick height, Pick delay, Place Height, Place Delay, Vacuum Discard,  Threshold, Vision Alignment, Speed,
//stack,   98,          1,    1 ,  92.27, 226.88, 0.00,     0805,   special,-1.00,            0,           0.00,         0,            No,            -40,       1,                50,

//continued, differences are here
// columns, rows, right top x , right top y, startx, starty,   skip, size correct,  thresholds for nozzles 1-4
// 9,        8,   162.27,      206.88,         3,       4,        No,      No,       -40,-40,-40,-40,


        sprintf ( str, "[REEL]|%d|%d|%d|%.2f|%.2f|%.2f|%s|%s|%.2f|%d|%.2f|%d|%s|%d|%d|%d|%d|%d|%.3f|%.3f|%d|%d|%s|%s|%d|%d|%d|%d\n",
                  j,									//%d 1
                  0,									//%d 2
                  ReelHead[j],							//%d 3
                  ReelOffSetX[j],						//%.2f 4
                  ReelOffSetY[j],						//%.2f 5
                  ReelPickAngle[j],						//%.2f 6
                  ReelFootPrint[j],						//%s 7
                  Reel[j],								//%s 8
                  ReelHeight[j],						//%.2f 9
                  ReelPickDelay[j],						//%d 10
                  ReelPlaceHeight[j],					//%.2f 11
                  ReelPlaceDelay[j],					//%d 12
                  ReelVacuumDetection[j] ? "YES" : "NO",//%s 13
                  ReelVacuumValue[j],					//%d 14
                  ReelVisionAlignment[j],				//%d 15
                  ReelMoveSpeed[j],						//%d 16

                  // changes here
                  trayColumns[j],						//%d 17
                  trayRows[j],							//%d 18
                  trayRightTopX[j],						//%f 19
                  trayRightTopY[j],						//%f 20
                  trayStartX[j], 						//%d 21
                  trayStartY[j],						//%d 22

                  //restarts
                  ReelSkip[j] ? "YES" : "NO",			//%s 23
                  ReelSizeCorrect[j] ? "YES" : "NO",		//%s 24
                  //thresholds
                  Nozzle1Thresholds[j], //%d 25
                  Nozzle2Thresholds[j], //%d 26
                  Nozzle3Thresholds[j], //%d 27
                  Nozzle4Thresholds[j] //%d 28
                );
    }

    printf ( str );
}



// parses a neoden 4 style string for a REEL
// reel index stored in file is +1 of actual index.
void parse_reel_line ( string reelString )
{
    int i;
    string a[];

    //dlgMessageBox ( reelString, "!OK" );
    // tokenise
    n = strsplit ( a, reelString, '|' );

    if ( n < 2 ) {
        n = strsplit ( a, reelString, ',' );

    }

    // get reel index, USS  starts at 1
    i = strtol ( alltrim ( a[1] ) );

    if ( i <= MAXREEL ) {

        // a[0] = [REEL] or stack
        // a[1] = feeder index
        // a[2] = type

        // head = nozzle index to combo box
        ReelHead[i] = strtol ( alltrim ( a[3] ) );

        // XY location of feeder
        ReelOffSetX[i] = strtod ( alltrim ( a[4] ) );
        ReelOffSetY[i] = strtod ( alltrim ( a[5] ) );

        // Angle
        ReelPickAngle[i] = strtod ( alltrim ( a[6] ) );

        // Footprint
        ReelFootPrint[i] = ( alltrim ( a[7] ) );

        // get rid of single space names
        if ( strlen ( ReelFootPrint[i] ) == 1 & strstr ( ReelFootPrint[i], " " ) == 0  ) {
            ReelFootPrint[i] = "";
        }

        // package and value is combined in the neoden stack
        if ( strlen ( alltrim ( a[8] ) ) ) {
            // Value
            Reel[i] = alltrim ( a[8] );

        }

        // get rid of single space names

        if ( strlen ( Reel[i] ) == 1 & strstr ( Reel[i], " " ) == 0 ) {
            Reel[i] = "";
        }

        // Pick Height
        ReelHeight[i] = strtod ( alltrim ( a[9] ) );

        // PickDelay
        ReelPickDelay[i] = strtol ( alltrim ( a[10] ) );

        // Placement Height
        ReelPlaceHeight[i] = strtod ( alltrim ( a[11] ) );

        // (Placement Delay)
        ReelPlaceDelay[i] = strtol ( alltrim ( a[12] ) );

        // Vacuum Detection (Yes/No)
        if ( alltrim ( a[13] ) == "Yes" ) {
            ReelVacuumDetection[i] = 1;

        } else {
            ReelVacuumDetection[i] = 0;
        }

        // Vacuum Value
        ReelVacuumValue[i] = strtol ( alltrim ( a[14] ) );


        // Vision Alignment
        ReelVisionAlignment[i] = strtol ( alltrim ( a[15] ) );

        // Speed
        ReelMoveSpeed[i] = strtol ( alltrim ( a[16] ) );

        if ( i < SPECIALREEL ) {
            // Feedbox Info
            // Feeding Rate
            ReelRate[i] = strtol ( alltrim ( a[17] ) );


            // Feed Strength
            ReelFeedStrength[i] = strtol ( alltrim ( a[18] ) );

            // Peel Strength
            ReelPeelStrength[i] = strtol ( alltrim ( a[19] ) );

            // Skip (Yes/No)
            if ( alltrim ( a[20] ) == "Yes" ) {
                ReelSkip[i] = 1;

            } else {
                ReelSkip[i] = 0;
            }

            // Size Correct ( CheckMark Yes/No)
            if ( alltrim ( a[21] ) == "Yes" ) {
                ReelSizeCorrect[i] = 1;

            } else {
                ReelSizeCorrect[i] = 0;
            }

            Nozzle1Thresholds[i] = strtol ( alltrim ( a[22] ) );
            Nozzle2Thresholds[i] = strtol ( alltrim ( a[23] ) );
            Nozzle3Thresholds[i] = strtol ( alltrim ( a[24] ) );
            Nozzle4Thresholds[i] = strtol ( alltrim ( a[25] ) );

        } else {
            // read special feeders.

            // (int)
            trayColumns[i] = strtol ( alltrim ( a[17] ) );
            trayRows[i] = strtol ( alltrim ( a[18] ) );

            // coords (real)
            trayRightTopX[i] = strtod ( alltrim ( a[19] ) );
            trayRightTopY[i] = strtod ( alltrim ( a[20] ) );

            // (int)
            trayStartX[i] = strtol ( alltrim ( a[21] ) );
            trayStartY[i] = strtol ( alltrim ( a[22] ) );

            // Skip (Yes/No)
            if ( alltrim ( a[23] ) == "Yes" ) {
                ReelSkip[i] = 1;

            } else {
                ReelSkip[i] = 0;
            }

            // Size Correct ( CheckMark Yes/No)
            if ( alltrim ( a[24] ) == "Yes" ) {
                ReelSizeCorrect[i] = 1;

            } else {
                ReelSizeCorrect[i] = 0;
            }

            Nozzle1Thresholds[i] = strtol ( alltrim ( a[25] ) );
            Nozzle2Thresholds[i] = strtol ( alltrim ( a[26] ) );
            Nozzle3Thresholds[i] = strtol ( alltrim ( a[27] ) );
            Nozzle4Thresholds[i] = strtol ( alltrim ( a[28] ) );
        }

    }
}

// the defaults are stored in config.ini,under [Stack] they are stored as Variants, motorola format 0x87 is the type,  then the 4 digits are a 32 bit float, if only three , add \x00 at end to pad.
// you pull it from a default csv if you switch on all the feeders in the feeder tab, or from the system setup page,smd configuration
// positions of reels in neoden4 as defaults, used to seed new
// also.. phew....

// starts from reel 1

// x coordinates of feeders
//                         reel 1           2           3            4           5           6      7     8     9       10
real default_reel_x[] = { 410.2232666, 409.8671875, 409.8482361, 409.9453125, 409.578125, 409.67, 409.52, 409.99, 410.02, 409.79,
//                             11    12    13      14      15      16      17      18      19     20
                          410.07, 409.55, 410.10, 410.04, 409.71, 409.97, 410.50, 410.60, 413.00, 23.05,
//                             21    22    23     24     25    26      27    28      29    30
                          23.04, 23.24, 22.98, 23.21, 24.09, 23.38, 23.29, 24.15, 23.46, 22.86,
//                             31    32    33     34     35    36      37    38      39    40
                          23.58, 23.21, 22.89, 22.86, 23.36, 23.43, 23.27, 23.38, 23.53, 23.62,
//                             41    42    43     44     45    46      47    48      49    50
                          23.82, 24.54, 20.80, 30.00, 30.00, 30.00, 30.00, 30.00, 400.00, 400.00,
//                             51     52     53     54     55      56       57      58     59     60
                          400.00, 400.00, 400.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00,
//                             61    62     63      64      65     66       67     68      69     70
                          150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00,
//                             71    72     73      74      75    76       77     78       79     80
                          150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00,
//                             81    82     83      84      85     86        87    88      89      90
                          150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 150.00, 132.64,
//                             91    92    93     94         95    96      97    98
                          121.00, 97.88, 159.49, 146.93, 134.39, 120.06, 107.73, 92.27


                        };

// y coordinates of feeders
//                         reel 1           2           3            4           5           6      7     8     9       10
real default_reel_y[] = { 88.27677155, 101.9296875, 115.0446625, 137.2856445, 142.01, 155.74, 168.95, 249.23, 262.96, 276.41,
//                             11    12    13     14     15    16      17    18      19    20
                          289.90, 303.18, 317.20, 330.72, 344.21, 357.44, 374.14, 391.64, 416.00, 24.34,
//                             21    22    23     24     25    26      27    28      29    30
                          37.43, 51.09, 64.63, 78.33, 91.90, 105.73, 119.48, 132.82, 146.66, 160.32,
//                             31    32    33     34     35    36      37    38      39    40
                          173.85, 187.41, 201.04, 214.54, 227.81, 241.46, 255.18, 268.63, 283.98, 301.84,
//                             41    42    43     44     45    46      47    48      49    50
                          320.50, 341.96, 374.70, 342.00, 355.00, 368.00, 381.00, 394.00, 35.00, 46.00,
//                             51    52    53     54     55    56      57    58      59    60
                          57.00, 68.00, 79.00, 50.00, 60.00, 70.00, 80.00, 90.00, 100.00, 342.19,
//                             61    62    63       64      65     66       67     68      69      70
                          120.00, 130.00, 140.00, 150.00, 160.00, 170.00, 180.00, 190.00, 200.00, 210.00,
//                             71    72    73      74      75     76       77     78       79      80
                          220.00, 230.00, 240.00, 250.00, 260.00, 270.00, 280.00, 290.00, 300.00, 310.00,
//                             81    82    83     84      85       86      87      88      89      90
                          320.00, 330.00, 340.00, 350.00, 360.00, 370.00, 380.00, 390.00, 400.00, 217.56,
//                             91    92    93     94       95      96      97     98
                          217.52, 211.92, 227.05, 227.88, 227.57, 227.38, 227.09, 226.88
                        };

// get the default feeder X address  for reel number 1-MAXREEL
real default_feeder_x ( int index )
{
    if ( index <= 0 ) { return 0; }

    if ( index > MAXREEL ) { return 0; }

    index--;
    return default_reel_x[index];
}

// get the default feeder X address  for reel number 1-MAXREEL
real default_feeder_y ( int index )
{
    if ( index <= 0 ) { return 0; }

    if ( index > MAXREEL ) { return 0; }

    index--;
    return default_reel_y[index];
}

//matching neoden4 defaults
void set_defaults()
{
    // fill some defaults
    for ( int j = 0; j <= MAXREEL; j++ ) {

        Reel[j] = "";// "Reel " + Num2Str(j);

        Nozzle1Thresholds[j] = 6;
        Nozzle2Thresholds[j] = 6;
        Nozzle3Thresholds[j] = 6;
        Nozzle4Thresholds[j] = 6;

        ReelPickDelay[j] = 0;
        ReelPeelStrength[j] = 80;
        ReelFeedStrength[j] = 50;
        ReelRate[j] = 4;
        ReelHeight[j] = 0.5;
        ReelHead[j] = 1;
        ReelPickAngle[j] = -90.0;

        // reel position defaults
        ReelOffSetX[j] = default_feeder_x ( j );
        ReelOffSetY[j] = default_feeder_y ( j );

        // trays ( only 49 up)
        trayColumns[j] = 1;
        trayRows[j] = 1;

        // coords

        trayStartX[j] = 1;
        trayStartY[j] = 1;

        // step size
        if ( j < SPECIALREEL ) {
            trayRightTopX[j] = 10;
            trayRightTopY[j] = 10;

        } else {
            trayRightTopX[j] = default_feeder_x ( j );
            trayRightTopY[j] = default_feeder_y ( j );
        }

        ReelMoveSpeed[j] = 100;
    }
}

void Load_Stack ( string who )
{
    string a[];    // use for spliting the line
    int i;
    int j;

    set_defaults();

    for ( j = 0; j < MAXREEL; j++ ) {

//idstac ID TY  NZ  X       Y       PAng   Foot  Val              PHGT  PID PHT   PLD VD  VCV VA  SPD  FRT FST PST SKP SZ
///       0  1   2    3        4     5      6         7            8     9   10    11 12  13  14   15   16  17  18 19  20
//stack,  1, 0,   , 413.00,  90.00, 90.00, 0805, footprint / one, 0.50, 9, 0.00, 10, Yes, -40, 0, 100, 4, 50, 80, Yes, Yes,
//stack,  2, 0,  1, 409.87, 101.73, 90.00, 0805, 0805/2.2nF,      0.50,0,0.50,0,No,-40,1,100,4,50,80,No,No,-40,-40,-40,-40,

        if ( who == "NSL" ) {

            for ( int nParts = 0; NSL_partList[nParts]; nParts++ ) {}

            if ( j < nParts ) {

                parse_reel_line ( NSL_partList[j] );
            }

        } else {

            string lines[];
            int n;
            int tr = 0;
            int nLines = fileread ( lines, UserStackFname ); // returns # of lines read

            for ( i = 0; i < nLines; i++ ) {

                parse_reel_line ( lines[i] );

            }

        }
    }
}

string Group_Parts ( string Enamex )
{

    int YES = 1;
    int NO = 0;
    string dummy, leftopr, rightopr, cmdx, slastseq, lasttoken;
    int dummy_written, nlastseq;
    string a[];
    int k, m, nrightopr;
    int startOfseq, prevseq;

    startOfseq = YES;
    dummy = "";
    dummy_written = NO;
    lasttoken = "";
    n = strsplit ( a, Enamex, ',' );

    if ( n != 0 ) {
        dummy += a[0];

        for ( k = 1; k < n; k++ ) {
            // cmdx+=" Token: "+a[k]+" \n";
            len = strlen ( a[k] );
            string temp = a[k];

            for ( m = 0; m < len; m++ ) { //find first occurance of a digit

                if ( isdigit ( temp[m] ) != 0 ) {
                    break;
                }
            }

            // m got the first digit position
            //split characters and numbers
            leftopr = strsub ( a[k], 0, m );
            rightopr = strsub ( a[k], m );


            nrightopr = strtol ( rightopr ); //sequence

            if ( startOfseq == YES ) {
                if ( dummy_written = NO ) {
                    if ( strlen ( dummy ) != 0 ) {
                        dummy += "-";
                    }

                    dummy += leftopr + rightopr;
                }

                prevseq = nrightopr;
                startOfseq = NO;
            }

            else {

                if ( nrightopr == prevseq + 1 ) { //got a sequence.

                    nlastseq = nrightopr; // store it for reference
                    slastseq = rightopr;
                    prevseq = nrightopr;
                    lasttoken = "-" + leftopr + slastseq; // write at end of loop

                    startOfseq = NO;


                }

                else {    // not sequence, write the previous one
                    dummy += "-";
                    dummy += leftopr + slastseq;
                    startOfseq = YES; //start the sequence again
                    lasttoken = "," + leftopr + rightopr;
                    dummy += lasttoken;
                    dummy_written = YES; // dummy variables was written as last token


                }


            }

        }
    }

    dummy += lasttoken;
    return dummy;

}

void ReelPage ( int reeloffset )
{

    board ( B ) {
        // 1. load default values if new
        // 2. Load save values if settings file exist
        //
        dlgTabPage ( "Reel Configuration " + Num2Str ( reeloffset ) ) {
            dlgVBoxLayout {
                dlgGridLayout {

                    int celly = 0;
                    int cellx = 0;
                    int reelNumber = 0;

                    for ( cellx = 0; cellx <= REELS_PER_PAGE; cellx++ )
                    {
                        celly = 0;

                        reelNumber = cellx + ( ( reeloffset - 1 ) * REELS_PER_PAGE ) ;

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Reel Assignments" );
                                }

                                else
                                {
                                    dlgSpacing ( 3 );

                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Reel Assignments" );

                                    }

                                    dlgLabel ( "Reel # " + Num2Str ( reelNumber ) );
                                }

                                dlgStretch ( 1 );
                            }

                        }

                        ///////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Nozzle" );

                                } else
                                {

                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Nozzle" );

                                    }

                                    //dlgSpinBox ( ReelHead[reelNumber], 1, 4 );
                                    dlgComboBox ( nozzleCombo, ReelHead[reelNumber] ) ;
                                }

                                // dlgStretch ( 1 );
                            }

                        }

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Reel Name" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Reel Name" );

                                    }

                                    dlgStringEdit ( Reel[reelNumber] );


                                }

                                // dlgStretch ( 1 );
                            }

                        }
                        //ReelFootPrint
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Reel Footprint" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Reel Footprint" );

                                    }

                                    dlgStringEdit ( ReelFootPrint[reelNumber] );


                                }

                                // dlgStretch ( 1 );
                            }

                        }

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Pick X" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Pick X" );

                                    }

                                    dlgRealEdit ( ReelOffSetX[reelNumber] );


                                }

                                // dlgStretch ( 1 );
                            }

                        }
                        ////////////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Pick Y" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Pick Y" );

                                    }

                                    dlgRealEdit ( ReelOffSetY[reelNumber] );


                                }

                                dlgStretch ( 1 );
                            }

                        }
                        ////////////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Pick Angle" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Pick Angle" );

                                    }

                                    dlgRealEdit ( ReelPickAngle[reelNumber] );


                                }

                                dlgStretch ( 1 );
                            }

                        }
                        ////////////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Pick Height" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Pick Height" );

                                    }

                                    dlgRealEdit ( ReelHeight[reelNumber], 0.00, 3 );

                                }

                                dlgStretch ( 0 );
                            }

                        }


                        ////////////////

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Pick Delay" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Pick Delay" );

                                    }

                                    dlgIntEdit ( ReelPickDelay[reelNumber] );


                                }

                                dlgStretch ( 0 );
                            }

                        }
                        ////////////////

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Place height" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Place Height" );

                                    }

                                    dlgRealEdit ( ReelPlaceHeight[reelNumber] );


                                }

                                dlgStretch ( 1 );
                            }

                        }
                        ////////////////

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Place Delay" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Place Delay" );

                                    }

                                    dlgIntEdit ( ReelPlaceDelay[reelNumber] );


                                }

                                dlgStretch ( 1 );
                            }

                        }
                        ////////////////

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Move Speed" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Move Speed" );

                                    }

                                    dlgIntEdit ( ReelMoveSpeed[reelNumber] );


                                }

                                dlgStretch ( 1 );
                            }

                        }
                        ////////////////
//ReelVisionAlignment
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Vision" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Vision" );

                                    }

                                    dlgCheckBox ( "", ReelVisionAlignment[reelNumber] );

                                }

                                dlgStretch ( 1 );
                            }

                        }

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Detect" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Detect" );

                                    }

                                    dlgCheckBox ( "", ReelVacuumDetection[reelNumber] );

                                }

                                dlgStretch ( 1 );
                            }

                        }

                        ////////////////

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Skip" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Skip" );

                                    }

                                    dlgCheckBox ( "", ReelSkip[reelNumber] );

                                }

                                dlgStretch ( 1 );
                            }

                        }
                        ////////////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "SizeCorrect" );
                                }

                                else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "SizeCorrect" );

                                    }

                                    dlgCheckBox ( "", ReelSizeCorrect[reelNumber] );

                                }

                                dlgStretch ( 1 );
                            }

                        }

                        if ( reelNumber < SPECIALREEL ) {
                            ////////////////
                            //ReelFeedStrength
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Feed Torque" ); //renamed in newer neoden software
                                    }

                                    else
                                    {
                                        dlgIntEdit ( ReelFeedStrength[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }
                            //ReelPeelStrength
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Peel Strength" );
                                    }

                                    else
                                    {
                                        dlgIntEdit ( ReelPeelStrength[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }


                            ////////////////// feed box



                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Feeding Rate" );
                                    }

                                    else
                                    {
                                        dlgSpinBox ( ReelRate[reelNumber], 0, 32 );
                                    }

                                    dlgStretch ( 1 );
                                }

                            }


                        } else {
                            //trayColumns[j],						//%d
                            //trayColumns
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Columns" );
                                    }

                                    else
                                    {
                                        if ( reelNumber == SPECIALREEL ) {
                                            dlgLabel ( "Columns" );

                                        }

                                        dlgIntEdit ( trayColumns[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }
                            // trayRows[j],							//%d
                            //trayColumns
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Rows" );
                                    }

                                    else
                                    {
                                        if ( reelNumber == SPECIALREEL ) {
                                            dlgLabel ( "Rows" );

                                        }

                                        dlgIntEdit ( trayRows[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }
                            //trayRightTopX[j],						//%f
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Right Top X" );
                                    }

                                    else
                                    {
                                        if ( reelNumber == SPECIALREEL ) {
                                            dlgLabel ( "Right Top X" );

                                        }

                                        dlgRealEdit ( trayRightTopX[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }
                            //trayRightTopY[j],						//%f
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Right Top Y" );
                                    }

                                    else
                                    {
                                        if ( reelNumber == SPECIALREEL ) {
                                            dlgLabel ( "Right Top Y" );

                                        }

                                        dlgRealEdit ( trayRightTopY[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }
                            //trayStartX[j], 						//%d
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Start X" );
                                    }

                                    else
                                    {
                                        if ( reelNumber == SPECIALREEL ) {
                                            dlgLabel ( "Start X" );

                                        }

                                        dlgIntEdit ( trayStartX[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }
                            //trayStartY[j]							//%d
                            dlgCell ( cellx, celly++ ) {
                                dlgVBoxLayout{
                                    if ( cellx == 0 )
                                    {
                                        dlgLabel ( "Start Y" );
                                    }

                                    else
                                    {
                                        if ( reelNumber == SPECIALREEL ) {
                                            dlgLabel ( "Start Y" );

                                        }

                                        dlgIntEdit ( trayStartY[reelNumber] );


                                    }

                                    dlgStretch ( 1 );
                                }

                            }
                        }

                        ///////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Noz 1 Thres" );

                                } else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Noz 1 Thres" );

                                    }

                                    {
                                        dlgComboBox ( ComboThresholds, Nozzle1Thresholds[reelNumber] ) ;
                                    }
                                }

                                // dlgStretch ( 1 );
                            }

                        }
                        ///////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Noz 2 Thres" );

                                } else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Noz 2 Thres" );

                                    }

                                    //dlgSpinBox ( ReelHead[reelNumber], 1, 4 );
                                    dlgComboBox ( ComboThresholds, Nozzle2Thresholds[reelNumber] ) ;
                                }

                                // dlgStretch ( 1 );
                            }

                        }
                        ///////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Noz 3 Thres" );

                                } else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Noz 3 Thres" );

                                    }

                                    dlgComboBox ( ComboThresholds, Nozzle3Thresholds[reelNumber] ) ;
                                }

                                // dlgStretch ( 1 );
                            }

                        }
                        ///////////
                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout{
                                if ( cellx == 0 )
                                {
                                    dlgLabel ( "Noz 4 Thres" );

                                } else
                                {
                                    if ( reelNumber == SPECIALREEL ) {
                                        dlgLabel ( "Noz 4 Thres" );

                                    }

                                    dlgComboBox ( ComboThresholds, Nozzle4Thresholds[reelNumber] ) ;
                                }

                                // dlgStretch ( 1 );
                            }

                        }

                        dlgCell ( cellx, celly++ ) {
                            dlgVBoxLayout {
                                dlgLabel ( "     " );
                                dlgStretch ( 1 );
                            }
                        }

                    }
                }

                dlgGridLayout {
                    int celly = 0;
                    dlgCell ( 1, celly++ )
                    {
                        dlgLabel ( " " );
                        dlgStretch ( 1 );
                    }
                    dlgCell ( 1, celly++ )
                    {

                        dlgPushButton ( "Load NullSpaceLabs.com's Standard Stack" ) {
                            Load_Stack ( "NSL" );
                            dlgRedisplay();
                            DP_stack_Loaded = 1;
                            dlgMessageBox ( "!NullSpaceLabs.com's Standard Stack Loaded\n", "&OK" );
                        }
                        dlgStretch ( 1 );
                    }
                    dlgCell ( 1, celly++ )
                    {
                        dlgPushButton ( "Load User's Standard Stack" ) {
                            UserStackFname = dlgFileOpen ( "Save User Standard Stack", filesetext ( B.name, ".USS" ), "*.USS" );

                            if ( UserStackFname != "" ) {
                                Load_Stack ( "USER" );
                                dlgRedisplay();
                                dlgMessageBox ( "!User Standard Stack Loaded\n", "&OK" );
                            }

                            dlgStretch ( 1 );
                        }
                    }
                    dlgCell ( 1, celly++ )
                    {

                        dlgPushButton ( "Save User's Standard Stack" ) {
                            UserStackFname = dlgFileSave ( "Save User Standard Stack", filesetext ( B.name, ".USS" ), "*.USS" );

                            if ( UserStackFname != "" ) {
                                output ( UserStackFname ) {
                                    for ( j = 0; j < MAXREEL; j++ ) {

                                        write_reel_line ( j + 1 );
                                    }

                                }
                                dlgMessageBox ( "!User Standard Stack saved\n", "&OK" );
                            }
                        }
                        dlgStretch ( 1 );
                    }
                    dlgCell ( 1, celly++ )
                    {
                        dlgLabel ( " " );
                        dlgStretch ( 1 );
                    }

                    dlgCell ( 1, celly++ )
                    {
                        dlgStretch ( 1 );
                        dlgPushButton ( "+&Accept" ) {
                            for ( i = 1; i <= REELS_PER_PAGE; i++ ) {
                                // Reel[0]="--------";

                                for ( j = 0; j < TopCounter; j++ ) {
                                    if ( CT_ReelNo[j] == i ) {
                                        CT_Eheight[j]  = ReelHeight[i];
                                        CT_Rate[j]  = ReelRate[i];
                                        // reels can have all variations of all 4 nozzles, but the component list can only have the first.
                                        CT_Ehead[j] = convert_to_nozzle ( ReelHead[i] );
                                    }
                                }

                                for ( j = 0; j < BottomCounter; j++ ) {
                                    if ( CB_ReelNo[j] == i ) {
                                        CB_Eheight[j]  = ReelHeight[i];
                                        CB_Rate[j]  = ReelRate[i];
                                        CB_Ehead[j] = convert_to_nozzle ( ReelHead[i] );
                                    }
                                }

                                // make a combo name of name + footprint to make reel selection easier
                                for ( j = 0; j <= MAXREEL; j++ ) {
                                    ReelNameAndFoot[j] = Num2Str ( j ) + ") " + Reel[j] + "/" + ReelFootPrint[j];
                                }


                            }

                            if ( DP_stack_Loaded == 1 ) {
                                DP_stack_Loaded = 2;
                            }

                            dlgMessageBox ( "!New Reel Configuration Accepted \n PCB top and PCB Bottom Height values are updated too ", "&OK" );

                        }
                        dlgPushButton ( "Cancel" ) {
                            dlgReset();
                            dlgMessageBox ( "!Changes Cancelled", "&OK" );
                        };
                        dlgStretch ( 1 );
                    }

                    dlgCell ( 1, celly++ )
                    {
                        dlgVBoxLayout {
                            dlgLabel ( "                                     " );


                            dlgStretch ( 1 );

                        }
                    }

                }
                dlgGridLayout {

                    dlgCell ( 0, 0 )
                    {
                        dlgHBoxLayout {
                            dlgLabel ( Help1 );
                            //dlgStretch(1);
                        }
                    }
                    dlgCell ( 1, 0 )
                    {
                        dlgHBoxLayout {

                            dlgLabel ( Help2 );
                            //dlgStretch(1);
                        }
                    }
                }

            }
            dlgVBoxLayout {
                dlgLabel ( "   " );
                dlgStretch ( 1 );
            }

        }
    }
}

real getBoardWidth() {
	real width = 0;
	board(B) {
     	char firstPoint = 'y';
     	real x1;
     	real y1;
     	real x2;
     	real y2;
		B.wires(W) {
			if (W.layer == LAYER_DIMENSION) {
				// Wire is on dimension layer
				real wx1 = u2mm(W.x1);
				real wy1 = u2mm(W.y1);
				real wx2 = u2mm(W.x2);
				real wy2 = u2mm(W.y2);

				// dlgMessageBox( "X1: " + Num2StrF(wx1) + ", Y1: " + Num2StrF(wy1) + ", X2: " + Num2StrF(wx2) + ", Y2: " + Num2StrF(wy2), "!OK" );
				// Start point of wire
				if(firstPoint == 'y') {
					firstPoint = 'n';
					x1 = wx1;
					x2 = wx1;
					y1 = wy1;
					y2 = wy2;
				} else {
					if(wx1 > x1) {
						x1 = wx1;
					}
					if(wx1 < x2) {
						x2 = wx1;
					}
					if(wy1 > y1) {
						y1 = wy1;
					}
					if(wy1 < y2) {
						y2 = wy1;
					}
				}

				// End point of wire
				if(wx2 > x1) {
					x1 = wx2;
				}
				if(wx2 < x2) {
					x2 = wx2;
				}
				if(wy2 > y1) {
					y1 = wy2;
				}
				if(wy2 < y2) {
					y2 = wy2;
				}

			}
	   	}

	   	if ( abs(x1 - x2) > width ) width = abs(x1 - x2);
	   	// real height = abs(y1 - y2);
		// real dim = width * height;
	}
	// dlgMessageBox( "board width: " + Num2StrF( width ), "!OK" );
	return width;
}


// Initialize variables
Reel[0] = "--------";
ReelNum[0] = "--";

for ( i = 0; i < MAXREEL ; i++ )
{
    g_Efeeder_Top[i] = 99;
    g_Efeeder_Bottom[i] = 99;
    comboSelected_Top[i] = 0;
    comboSelected_Bottom[i] = 0;
    // leave it blank
    Reel[i + 1] = "";
    // to help with the combox box issue
    ReelNum[i + 1] = "" + Num2Str ( i + 1 );

    g_Head_Top[i] = 1;
    g_Head_Bottom[i] = 1;
    g_Eheight_Top[i] = 0.00;
    g_Eheight_Bottom[i] = 0.00;
    g_TapeSkip_Top[i] = 0;
    g_TapeSkip_Bottom[i] = 0;
    g_Erate_Top[i] = 0;
    g_Erate_Bottom[i] = 0;
}


for ( i = 0; i < 4; i++ )
{
    RotationOffset[i] = Num2Str ( i * 90 );
}

// peel box feed rates 10, 100 in steps of 10
for ( i = 0; i < 10; i++ )
{
    FeedRates[i] = Num2Str ( ( i + 1 ) * 10 );
}

set_defaults();

if ( project.board ) project.board ( B )
{
    workdir = filedir ( B.name );
    SourceFname = filename ( B.name );
    // remove extension
    string s = SourceFname;
    char c = '.';
    int pos = strrchr ( s, c );

    if ( pos >= 0 ) {
        s[pos] = '\0';
        SourceFname = s;
    }

    StackFname = workdir + SourceFname + ".PnP"; // same filename with the board

    //---- try to get all parts in the board loaded to memory
    //     Ename[j],Equantity[j],Evalue[j],Epackagename[j] etc


    B.elements ( E ) {


        if ( skip_part ( E ) == 0 ) {
            continue;
        }

        E.package.contacts ( C ) {

            int wasSmd;


            if ( C.smd ) {
                if ( C.smd.layer == LAYER_TOP ) {
                    wasSmd = 1;
                    layer = "Top";
                }

                else {
                    if ( C.smd.layer == LAYER_BOTTOM ) {
                        wasSmd = 1;
                        layer = "Bottom";
                    }

                    else {
                        layer = "???";   // layer was not defined to be top or bottom
                    }
                }
            }

            else {
                wasSmd = 0;
                continue;
            }
        }

        sprintf ( partsX, "%.2f", u2mm ( E.x ) );
        sprintf ( partsY, "%.2f", u2mm ( E.y ) );
        sprintf ( partsRotation, "%.2f", E.angle );
        Ename[counter] = E.name;
        Evalue[counter] = E.value;
        Epackagename[counter] = E.package.name;
        ElibrarySource[counter] = E.package.library;
        EpartsX[counter] = partsX;
        EpartsY[counter] = partsY;
        Elayer[counter] = layer;
        Eangle[counter] = partsRotation;
        Eheadline[counter] = E.package.headline;
        Eptr[counter] = counter; //  line numbers, when Eptr[0] ,value is 0
        counter++;
    }

    // then group contents according to values and package, must create a group
    // index holds all the unique elements after grouping.
    found = 0;

    for ( j = 0; j < counter; j++ ) {
        if ( index == 0 ) { // initial content
            g_Ename[index] = alltrim ( Ename[j] );
            g_EnameTemp[index] = alltrim ( Ename[j] );
            g_Evalue[index] = alltrim ( Evalue[j] );
            g_Epackagename[index] = alltrim ( Epackagename[j] );
            g_ElibrarySource[index] = ElibrarySource[j];
            g_EpartsX[index] = "";   // EpartsX[j];     //coordinates parts-do not use
            g_EpartsY[index] = "";   // EpartsY[j];
            g_Elayer[index] = Elayer[j];
            g_Efeeder[index] = 99;  // to be filled up- reel assignment
            g_Head[index] = 1;   // valid values are 1,2,3,4 only
            g_Equantity[index] = 1; // always 1
            g_Erate[index] = 0;    // to be filled up
            g_Eangle[index] = "";
            g_Eheight[index] = 0.0;   // to be filled up
            g_ptr[index] = index;      // each line must have a number
            g_class[index] = grouping;
            g_backptr[index] = alltrim ( Num2Str ( Eptr[j] ) );
            g_Eheadline[index] = Eheadline[j];
            index++;
        }

        else {
            // locate the part and group(package, value, layer)
            found = 0; // not found yet

            for ( i = 0; i < index; i++ ) {
                if ( strupr ( alltrim ( Epackagename[j] ) ) == strupr ( g_Epackagename[i] ) ) {
                    if ( strupr ( alltrim ( Evalue[j] ) ) == strupr ( g_Evalue[i] ) )  {
                        if ( Elayer[j] == g_Elayer[i] ) {   // group
                            g_Equantity[i]++;
                            g_Ename[i] += "," + alltrim ( Ename[j] ); // append so that parts name will be c1,c2,c3 etc

                            g_class[i] = grouping;
                            g_backptr[i] += "|" + alltrim ( Num2Str ( Eptr[j] ) ); // points back 5|12|13|16|22
                            found = 1; // found one
                        }
                    }
                }
            }

            if ( found == 0 ) { // found nothing, create new entry, index was incremented before
                g_Ename[index] = alltrim ( Ename[j] );
                g_EnameTemp[index] = alltrim ( Ename[j] );
                g_Evalue[index] = alltrim ( Evalue[j] );
                g_Epackagename[index] = alltrim ( Epackagename[j] );
                g_ElibrarySource[index] = ElibrarySource[j];
                g_EpartsX[index] = "";    //EpartsX[j];     //coordinates parts-Do not use
                g_EpartsY[index] = "";    //EpartsY[j];
                g_Elayer[index] = Elayer[j];
                g_Efeeder[index] = 99; // to be filled up- reel assignment
                g_Head[index] = 1;     // initially assign head # 1
                g_Equantity[index] = 1; // always 1
                g_Erate[index] = 0;    // to be filled up
                g_Eangle[index] = "";
                g_Eheight[index] = 0.0;   // to be filled up
                g_Eheadline[index] = Eheadline[j];
                g_ptr[index] = index;
                g_class[index] = grouping;

                g_backptr[i] = alltrim ( Num2Str ( Eptr[j] ) );

                grouping++;
                index++;
            }

        }


    }

    int teststring;


    for ( j = 0; j < index; j++ ) { //load for display
        string equant = Num2Str ( g_Equantity[j] );
        string gptr = Num2Str ( g_ptr[j] );

        if ( g_Equantity[j] > 3 ) {
            dummy_grouping = Group_Parts ( g_Ename[j] );
            g_Ename_group[j] = dummy_grouping;
        }

        else {
            g_Ename_group[j] = g_Ename[j] ;
        }

        partslist[j] = g_Ename_group[j] + " \t" + equant + " \t" + g_Evalue[j] + " \t" + g_Epackagename[j] + " \t" + g_ElibrarySource[j] + " \t" + g_Eheadline[j] + " \t" + g_Elayer[j];

        if ( g_Elayer[j] == "Top" ) {
            components_Top_ptr[TopCounter] = j; // keep track of component
            string gxname;

            components_Top[TopCounter] = alltrim ( g_Ename[j] );
            grp_components_Top[TopCounter] = g_Ename_group[j];
            component_quantity_Top[TopCounter] = alltrim ( equant );
            component_value_Top[TopCounter] = alltrim ( g_Evalue[j] );
            component_packagename_Top[TopCounter] = alltrim ( g_Epackagename[j] );
            CT_Eheight[TopCounter] = 0.00;
            CT_Ehead[TopCounter] = 1;
            CT_Skip[TopCounter] = 0;
            CT_Rate[TopCounter] = 0;

            int combolen_Top = strlen ( components_Top[TopCounter] );

            if ( combolen_Top > maxComboLen_Top ) {
                maxComboLen_Top = combolen_Top;
            }

            CT_ReelNo[TopCounter] = 0; // used as selections, will contains reel # selected
            CT_EpartsX[TopCounter] = g_EpartsX[j];
            CT_EpartsY[TopCounter] = g_EpartsX[j];
            CT_Epackagename[TopCounter] = g_Epackagename[j];
            CT_Evalue[TopCounter] = g_Evalue[j];
            CT_Elayer[TopCounter] = g_Elayer[j];
            CT_class[TopCounter] = g_class[j];
            CT_backptr[TopCounter] = g_backptr[j];
            TopCounter++;

        }

        else {
            if ( g_Elayer[j] == "Bottom" )  {
                string gxname;
                components_Bottom_ptr[BottomCounter] = j;
                components_Bottom[BottomCounter] = alltrim ( g_Ename[j] );
                grp_components_Bottom[BottomCounter] = g_Ename_group[j];
                component_quantity_Bottom[BottomCounter] = alltrim ( equant );
                component_value_Bottom[BottomCounter] = alltrim ( g_Evalue[j] );
                component_packagename_Bottom[BottomCounter] = alltrim ( g_Epackagename[j] );
                CB_Eheight[BottomCounter] = 0.00;
                CB_Ehead[BottomCounter] = 1;
                CB_Skip[BottomCounter] = 0;
                CB_Rate[BottomCounter] = 0;
                int combolen_Bottom = strlen ( components_Bottom[BottomCounter] );

                if ( combolen_Bottom > maxComboLen_Bottom ) {
                    maxComboLen_Bottom = combolen_Bottom;
                }

                CB_ReelNo[BottomCounter] = 0; // initially select reel 0
                CB_EpartsX[BottomCounter] = g_EpartsX[j];
                CB_EpartsY[BottomCounter] = g_EpartsX[j];
                CB_Epackagename[BottomCounter] = g_Epackagename[j];
                CB_Evalue[BottomCounter] = g_Evalue[j];
                CB_Elayer[BottomCounter] = g_Elayer[j];
                CB_class[BottomCounter] = g_class[j];   //grouping
                CB_backptr[BottomCounter] = g_backptr[j];
                BottomCounter++;
            }

            else {
                string gxname;
                components_Mid_ptr[MidCounter] = j;
                components_Mid[MidCounter] = alltrim ( g_Ename[j] );
                grp_components_Mid[MidCounter] = g_Ename_group[j];
                component_quantity_Mid[MidCounter] = alltrim ( equant );
                component_value_Mid[MidCounter] = alltrim ( g_Evalue[j] );
                component_packagename_Mid[MidCounter] = alltrim ( g_Epackagename[j] );
                CM_Eheight[MidCounter] = 0.00;
                CM_Ehead[MidCounter] = 1;
                CM_Skip[MidCounter] = 0;
                CM_Rate[MidCounter] = 0;
                int combolen_Mid = strlen ( components_Mid[MidCounter] );

                if ( combolen_Mid > maxComboLen_Mid ) {
                    maxComboLen_Mid = combolen_Mid;
                }

                CM_ReelNo[MidCounter] = 0; // initially select reel 0
                CM_EpartsX[MidCounter] = g_EpartsX[j];
                CM_EpartsY[MidCounter] = g_EpartsX[j];
                CM_Epackagename[MidCounter] = g_Epackagename[j];
                CM_Evalue[MidCounter] = g_Evalue[j];
                CM_Elayer[MidCounter] = g_Elayer[j];
                CM_class[MidCounter] = g_class[j];   //grouping
                CM_backptr[MidCounter] = g_backptr[j];
                MidCounter++;

            }
        }
    }

    // store config settings
    string paramsFilename;

    paramsFilename = workdir + SourceFname + ".cfg";

    // load config parameters
    if ( filesize ( paramsFilename ) > 0 ) {
        string lines[];
        int nLines = fileread ( lines, paramsFilename ); // returns # of lines read

        for ( i = 0; i < nLines; i++ ) {
            string a[];    // use for spliting the line

            n = strsplit ( a, lines[i], ',' );

            board_offset_x = strtod ( alltrim ( a[0] ) );
            board_offset_y = strtod ( alltrim ( a[1] ) );
            board_move_override = strtod ( alltrim ( a[2] ) );

            g_board_rotation = strtod ( alltrim ( a[3] ) );
        }

    } else {
        board_offset_x = 0;
        board_offset_y = 0;
        board_move_override = 100;
        g_board_rotation = 0;

    }

    // load values from stack file

    if ( filesize ( StackFname ) > 0 ) {
        string lines[];
        int tc = 0;
        int tb = 0;
        int tm = 0;
        int tr = 0;
        int nLines = fileread ( lines, StackFname ); // returns # of lines read

        for ( i = 0; i < nLines; i++ ) {

            string a[];    // use for spliting the line

            n = strsplit ( a, lines[i], '|' );

            if ( alltrim ( a[0] ) == "[TOP]" ) {

                if ( components_Top[tc] == alltrim ( a[1] ) ) {
                    CT_ReelNo[tc] = strtol ( alltrim ( a[2] ) );
                    CT_Ehead[tc] = strtol ( alltrim ( a[3] ) );
                    CT_Eheight[tc] = strtod ( alltrim ( a[4] ) );
                    CT_Skip[tc] = strtol ( alltrim ( a[5] ) );
                    CT_Rate[tc] = strtol ( alltrim ( a[6] ) );
                }

                tc++;
            }

            if ( alltrim ( a[0] ) == "[BOTTOM]" ) {

                if ( components_Bottom[tb] == alltrim ( a[1] ) ) {
                    CB_ReelNo[tb] = strtol ( alltrim ( a[2] ) );
                    CB_Ehead[tb] = strtol ( alltrim ( a[3] ) );
                    CB_Eheight[tb] = strtod ( alltrim ( a[4] ) );
                    CB_Skip[tb] = strtol ( alltrim ( a[5] ) );
                    CB_Rate[tb] = strtol ( alltrim ( a[6] ) );
                }

                tb++;
            }

            if ( alltrim ( a[0] ) == "[???]" ) {
                if ( components_Mid[tm] == alltrim ( a[1] ) ) {
                    CM_ReelNo[tm] = strtol ( alltrim ( a[2] ) );
                    CM_Ehead[tm] = strtol ( alltrim ( a[3] ) );
                    CM_Eheight[tm] = strtod ( alltrim ( a[4] ) );
                    CM_Skip[tm] = strtol ( alltrim ( a[5] ) );
                    CM_Rate[tm] = strtol ( alltrim ( a[6] ) );
                }

                tm++;
            }

            if ( alltrim ( a[0] ) == "[REEL]" ) {

                //dlgMessageBox ( lines[i], "&OK" );

                parse_reel_line ( lines[i] );

                tr++;
            }


        }

        //dlgMessageBox("!Final: comboSelected_Bottom[0]= "+Num2Str(comboSelected_Bottom[0])+"\n","&OK");

    }

    Result = 5;


    while ( Result == 5 )
        Result = dlgDialog ( "DP Neoden 4 Pick and Place " ) {
        dlgTabWidget {
            dlgTabPage ( "CSV Export" )
            {

                dlgHBoxLayout {
                    dlgStretch ( 1 );
                    dlgLabel ( "NullSpaceLabs - Neoden 4 Pick n Place\n                     Version " + VERSION );
                    dlgStretch ( 1 );
                }

                dlgHBoxLayout {


                    dlgTextView ( Text );



                }

                // dlgHBoxLayout {
                // dlgLabel("Home: X and Y origin:           ");
                // dlgRealEdit(Xorigin, 0.00, 280.00);
                // dlgRealEdit(Yorigin, 0.00, 280.00);
                // dlgSpacing(700);
                // dlgStretch(1);

                // }
                // dlgHBoxLayout {
                // dlgLabel("Size of PCB Board:              ");
                // dlgRealEdit(BoardX, 20.00, 220.00);
                // dlgRealEdit(BoardY, 20.00, 200.00);
                // dlgSpacing(700);
                // dlgStretch(1);

                // }
                // dlgHBoxLayout {
                // dlgLabel("Number of Boards in X direction:");
                // dlgIntEdit(nBoardsinX,0,20);
                // dlgSpacing(700);
                // dlgStretch(1);

                // }
                // dlgHBoxLayout {
                // dlgLabel("Number of Boards in Y direction:");
                // dlgIntEdit(nBoardsinY,0,20);
                // dlgSpacing(700);
                // dlgStretch(1);

                // }
                // dlgHBoxLayout {
                // dlgLabel("Gap in mm between Boards in X direction:");
                // dlgRealEdit(GapBoardX, -100.00, 300.00);
                // dlgSpacing(700);
                // dlgStretch(1);

                // }
                // dlgHBoxLayout {
                // dlgLabel("Gap in mm between Boards in Y direction:");
                // dlgRealEdit(GapBoardY, -100.00, 300.00);
                // dlgSpacing(700);
                // dlgStretch(1);

                // }


                dlgHBoxLayout{
                    dlgLabel ( "Set board offset (moves position of all components by this amount in mm) " );
                    dlgStretch ( 1 );
                    dlgLabel ( "X" );
                    dlgRealEdit ( board_offset_x );
                    dlgLabel ( "mm" );
                    dlgStretch ( 1 );
                    dlgLabel ( "Y" );
                    dlgRealEdit ( board_offset_y );
                    dlgLabel ( "mm" );
                }

                dlgHBoxLayout{
                    dlgLabel ( "Override move speed in %:" );

                    dlgIntEdit ( board_move_override );
                    dlgLabel ( "%" );
                    dlgStretch ( 1 );
                }
                dlgHBoxLayout{
                    dlgLabel ( "Board rotation in degrees:" );

                    dlgRealEdit ( g_board_rotation );
                    dlgLabel ( "o" );
                    dlgStretch ( 1 );
                }


                dlgHBoxLayout {
                    dlgLabel ( "Enter CSV Export File (TOP):" );
                    csvnametop = workdir + SourceFname + "_Top.csv";
                    dlgStringEdit ( csvnametop );
                    dlgPushButton ( "Browse" )
                    {
                        csvnametop = dlgFileSave ( "Save Exported CSV", filesetext ( B.name, ".csv" ), "*.csv" );
                    }
                }
                dlgHBoxLayout {
                    dlgLabel ( "Enter CSV Export File (Bottom):" );
                    csvnamebottom = workdir + SourceFname + "_Bottom.csv";
                    dlgStringEdit ( csvnamebottom );
                    dlgPushButton ( "Browse" )
                    {
                        csvnamebottom = dlgFileSave ( "Save Exported CSV", filesetext ( B.name, ".csv" ), "*.csv" );
                    }
                }
                dlgHBoxLayout {
                    dlgLabel ( "Save PNP stack setup file:" );
                    // StackFname=workdir+SourceFname+".PnP";
                    dlgStringEdit ( StackFname );
                    dlgPushButton ( "browse" )
                    {
                        StackFname = dlgFileSave ( "Save Neoden4 Stack Setup", filesetext ( B.name, ".PnP" ), "*.PnP" );
                    }
                }

                dlgSpacing ( 10 );
                dlgHBoxLayout {
                    dlgStretch ( 1 );
                    dlgPushButton ( "+OK" )    dlgAccept();
                    dlgPushButton ( "Cancel" ) dlgReject();
                }
                dlgHBoxLayout {
                    dlgStretch ( 1 );

                }
            }

            dlgTabPage ( "Parts list" )
            {
                dlgHBoxLayout {
                    dlgStretch ( 1 );
                    dlgLabel ( "Parts in the Board" );
                    dlgStretch ( 1 );
                }
                dlgHBoxLayout {
                    Selected = -1;
                    dlgListView ( "Part\tQuantity\tValue\tPackage\tLibrary\tDescription\tLayer", partslist, Selected )
                    {
                        // dlgMessageBox("You have selected " + partslist[Selected]);

                    };

                }


            }
            int pagex = 0;
            int pagey = 0;
            int pagez = 0;
            int var1;
            int MyLayer;
            tabloop = 0;  // tab
            int TopAddLine[], BottomAddLine[], MidAddLine[];

            int TopXcounter[];  // handles counter per tab containts topcounter, bottomcounter
            int BottomXcounter[];  // handles counter per tab containts topcounter, bottomcounter
            int MidXcounter[];  // handles counter per tab containts topcounter, bottomcounter
            int tabpages[];  // how many pages per topcounter

            AddTab = 0;
            int temp;
            pcb_layers[AddTab] = "PCB Top Layer";
            temp = TopCounter;
            TopAddLine[pagex] = 0; // # of line per page to add , when pagex=0,

            while ( temp > 0 )
            {
                if ( temp > LinesPerTab ) {
                    TopXcounter[pagex] = LinesPerTab;
                    pcb_layers[AddTab++] = "PCB Top Layer " + Num2Str ( pagex );
                    temp = temp - LinesPerTab;

                    TopAddLine[pagex + 1] = LinesPerTab + TopAddLine[pagex];

                    pagex++;
                }

                else {
                    TopXcounter[pagex] = temp;

                    if ( pagex != 0 ) {
                        pcb_layers[AddTab++] = "PCB Top Layer " + Num2Str ( pagex++ );
                    }

                    else {
                        AddTab++;
                    }

                    temp = 0;

                }

            }

            pagey = 0;


            pcb_layers[AddTab] = "PCB Bottom Layer";
            temp = BottomCounter;
            BottomAddLine[pagey] = 0;   // lines to add in this page

            while ( temp > 0 )
            {
                if ( temp > LinesPerTab ) {
                    BottomXcounter[pagey] = LinesPerTab;
                    pcb_layers[AddTab++] = "PCB Bottom Layer " + Num2Str ( pagey );
                    temp = temp - LinesPerTab;

                    BottomAddLine[pagey + 1] = LinesPerTab + BottomAddLine[pagey]; // line to add in this page + accumulated lines, to track array

                    pagey++;
                }

                else {
                    BottomXcounter[pagey] = temp;

                    if ( pagey != 0 ) {
                        pcb_layers[AddTab++] = "PCB Bottom Layer " + Num2Str ( pagey++ );
                    }

                    else {
                        AddTab++;
                    }

                    temp = 0;

                }

            }

            pagez = 0;
            pcb_layers[AddTab] = "PCB X Layer" ;
            temp = MidCounter;
            MidAddLine[pagez] = 0;

            while ( temp > 0 )
            {
                if ( temp > LinesPerTab ) {
                    MidXcounter[pagez] = LinesPerTab;
                    pcb_layers[AddTab++] = "PCB X Layer " + Num2Str ( pagez );
                    temp = temp - LinesPerTab;
                    MidAddLine[pagez + 1] = LinesPerTab + MidAddLine[pagez];
                    pagez++;
                }

                else {
                    MidXcounter[pagez] = temp;

                    if ( pagez != 0 ) {
                        pcb_layers[AddTab++] = "PCB X Layer " + Num2Str ( pagez++ );
                    }

                    else {
                        AddTab++;
                    }

                    temp = 0;

                }

            }

            pagex = 0;
            pagey = 0;
            pagez = 0;

            for ( tabloop = 0; tabloop < AddTab; tabloop++ )
            {
                string pcb_layer = pcb_layers[tabloop];
                int localcounter;
                int pos;
                pos = strstr ( pcb_layer, "Top" );

                if ( pos >= 0 ) {
                    localcounter = TopXcounter[pagex];
                    MyLayer = 0;
                }

                else {
                    pos = strstr ( pcb_layer, "Bottom" );

                    if ( pos >= 0 ) {
                        localcounter = BottomXcounter[pagey];
                        MyLayer = 1;
                    }

                    else {

                        localcounter = MidXcounter[pagez];
                        MyLayer = 2;
                    }
                }

                dlgTabPage ( pcb_layer ) {

                    dlgSpacing ( 0 );

                    // make a combo name of name + footprint to make reel selection easier
                    for ( j = 0; j <= MAXREEL; j++ ) {
                        ReelNameAndFoot[j] = Num2Str ( j  ) + ") " + Reel[j] + "/" + ReelFootPrint[j];
                    }

                    dlgVBoxLayout {
                        dlgGridLayout {
                            int celly = 0;
                            int cellx = 0;

                            for ( cellx = 0; cellx <= localcounter; cellx++ )
                            {
                                celly = 0;
                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Parts Label            " );
                                        }

                                        else
                                        {
                                            dlgSpacing ( 3 );

                                            switch ( MyLayer ) {
                                                case 0 :
                                                    dlgLabel ( grp_components_Top[cellx - 1 + TopAddLine[pagex]] );
                                                    break;

                                                case 1 :
                                                    dlgLabel ( grp_components_Bottom[cellx - 1 + BottomAddLine[pagey]] );
                                                    break;

                                                case 2 :
                                                    dlgLabel ( grp_components_Mid[cellx - 1 + MidAddLine[pagez]] );
                                                    break;
                                            }
                                        }

                                        //  dlgStretch ( 1 );
                                    }

                                }

                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Quantity " );
                                        }

                                        else
                                        {
                                            dlgSpacing ( 3 );

                                            switch ( MyLayer ) {
                                                case 0:
                                                    dlgLabel ( component_quantity_Top[cellx - 1 + TopAddLine[pagex]] );
                                                    break;

                                                case 1:
                                                    dlgLabel ( component_quantity_Bottom[cellx - 1 + BottomAddLine[pagey]] );
                                                    break;

                                                case 2:
                                                    dlgLabel ( component_quantity_Mid[cellx - 1 + MidAddLine[pagez]] );
                                                    break;

                                            }
                                        }

                                        //dlgStretch ( 1 );
                                    }
                                }

                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Value    " );
                                        }

                                        else
                                        {
                                            dlgSpacing ( 4 );

                                            switch ( MyLayer ) {
                                                case 0:
                                                    dlgLabel ( component_value_Top[cellx - 1 + TopAddLine[pagex]] );
                                                    break;

                                                case 1:
                                                    dlgLabel ( component_value_Bottom[cellx - 1 + BottomAddLine[pagey]] );
                                                    break;

                                                case 2:
                                                    dlgLabel ( component_value_Mid[cellx - 1 + MidAddLine[pagez]] );
                                                    break;
                                            }
                                        }

                                    }
                                }


                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Package" );
                                        }

                                        else
                                        {
                                            dlgSpacing ( 3 );

                                            switch ( MyLayer ) {
                                                case 0:
                                                    dlgLabel ( component_packagename_Top[cellx - 1 + TopAddLine[pagex]] );
                                                    break;

                                                case 1:
                                                    dlgLabel ( component_packagename_Bottom[cellx - 1 + BottomAddLine[pagey]] );
                                                    break;

                                                case 2:
                                                    dlgLabel ( component_packagename_Mid[cellx - 1 + MidAddLine[pagez]] );
                                                    break;
                                            }
                                        }

                                        dlgStretch ( 1 );
                                    }
                                }

                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Reel Assignment" );
                                        }

                                        else
                                        {
                                            switch ( MyLayer ) {
                                                case 0:
                                                    dlgComboBox ( ReelNameAndFoot, CT_ReelNo[cellx - 1 + TopAddLine[pagex]] ) dlgRedisplay();
                                                    break;

                                                case 1:
                                                    dlgComboBox ( ReelNameAndFoot, CB_ReelNo[cellx - 1 + BottomAddLine[pagey]] ) dlgRedisplay();
                                                    break;

                                                case 2:
                                                    dlgComboBox ( ReelNameAndFoot, CM_ReelNo[cellx - 1 + MidAddLine[pagez]] ) dlgRedisplay();
                                                    break;
                                            }
                                        }


                                        // dlgStretch ( 1 );
                                    }

                                }

                                //ReelNumber, can't find a way to make this update after Reel Assignment is changed. it only updates next load
                                // changing it to a dlgSpinBox makes Reel Assignment change, but now not the other way around!
                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Reel Number" );
                                        }

                                        else
                                        {
                                            switch ( MyLayer ) {
                                                case 0:

                                                    dlgComboBox ( ReelNum, CT_ReelNo[cellx - 1 + TopAddLine[pagex]] )  dlgRedisplay();
                                                    break;

                                                case 1:
                                                    dlgComboBox ( ReelNum, CB_ReelNo[cellx - 1 + BottomAddLine[pagey]] ) dlgRedisplay();
                                                    break;

                                                case 2:
                                                    dlgComboBox ( ReelNum, CM_ReelNo[cellx - 1 + MidAddLine[pagez]] )  dlgRedisplay();
                                                    break;
                                            }
                                        }

                                        // dlgStretch ( 1 );

                                    }

                                }


                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        dlgSpacing ( 0 );
                                        dlgStretch ( 0 );

                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Nozzle" );
                                        }

                                        else
                                        {
                                            switch ( MyLayer ) {
                                                case 0:
                                                    dlgSpinBox ( CT_Ehead[cellx - 1 + TopAddLine[pagex]], 1, 4 );

                                                    break;

                                                case 1:
                                                    dlgSpinBox ( CB_Ehead[cellx - 1 + BottomAddLine[pagey]], 1, 4 );
                                                    break;

                                                case 2:
                                                    dlgSpinBox ( CM_Ehead[cellx - 1 + MidAddLine[pagez]], 1, 4 );

                                                    break;
                                            }
                                        }

                                        //dlgStretch ( 1 );
                                    }

                                }

                                // dropping this for now as it won't reflect changes made in the reel configurations height
                                if ( 0 ) {
                                    dlgCell ( cellx, celly++ ) {
                                        dlgVBoxLayout{
                                            dlgSpacing ( 0 );

                                            if ( cellx == 0 )
                                            {
                                                dlgLabel ( "Height" );
                                            }

                                            else
                                            {
                                                dlgSpacing ( 0 );

                                                switch ( MyLayer ) {
                                                    case 0:
                                                        dlgLabel ( Num2StrF ( CT_Eheight[cellx - 1 + TopAddLine[pagex]] ) );
                                                        break;

                                                    case 1:
                                                        dlgLabel ( Num2StrF ( CB_Eheight[cellx - 1 + BottomAddLine[pagey]] ) );
                                                        break;

                                                    case 2:
                                                        dlgLabel ( Num2StrF ( CM_Eheight[cellx - 1 + MidAddLine[pagez]] ) );
                                                        break;
                                                }
                                            }

                                            dlgStretch ( 1 );
                                        }
                                    }
                                }

                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        dlgSpacing ( 0 );

                                        if ( cellx == 0 )
                                        {
                                            dlgLabel ( "Skip" );
                                        }

                                        else
                                        {


                                            switch ( MyLayer ) {
                                                case 0:
                                                    dlgSpinBox ( CT_Skip[cellx - 1 + TopAddLine[pagex]], 0, 1 );
                                                    break;

                                                case 1:
                                                    dlgSpinBox ( CB_Skip[cellx - 1 + BottomAddLine[pagey]], 0, 1 );
                                                    break;

                                                case 2:
                                                    dlgSpinBox ( CM_Skip[cellx - 1 + MidAddLine[pagez]], 0, 1 );
                                                    break;
                                            }
                                        }

                                        dlgStretch ( 1 );
                                    }
                                }

                                dlgCell ( cellx, celly++ ) {
                                    dlgVBoxLayout {
                                        dlgLabel ( " " );

                                        dlgStretch ( 1 );
                                    }

                                }
                            }
                        }
                        dlgStretch ( 1 );


                    }
                    dlgVBoxLayout {
                        dlgStretch ( 1 );
                    }
                    dlgStretch ( 1 );
                }

                switch ( MyLayer ) {
                    case 0:
                        pagex++;
                        break;

                    case 1:
                        pagey++;
                        break;

                    case 2:
                        pagez++;
                        break;
                }
            }

            int page;

            for ( page = 1 ; page <= MAXREEL / REELS_PER_PAGE ; page ++ )
            {
                ReelPage ( page );
            }

        }
    };


    if ( Result == 1 ) {


        fileerror();

        // store config settings
        string paramsFilename;

        paramsFilename = workdir + SourceFname + ".cfg";

        if ( paramsFilename != "" ) {
            output ( paramsFilename ) {
                printf ( "%.3f,%.3f,%d,%f\n", board_offset_x, board_offset_y, board_move_override, g_board_rotation );
            }
        }

        string csvfilename;

        int csv;
		real boardWidth = getBoardWidth();

        for ( csv = 0; csv < 2 ; csv++ ) {
            if ( csv == 0 ) {
                csvfilename = csvnametop;
            }

            else {
                csvfilename = csvnamebottom;
            }

            output ( csvfilename ) {
                line = 1;

                if ( debug == 1 ) {
                    printf ( "#Feeder,Feeder ID,Type,Nozzle,X,Y,Angle,Footprint,Value,Pick height,Pick delay,Placement height,Placement delay,Vacuum detection,Vacuum value,Vision alignment,Speed,\n" );
                    printf ( "Part,Value,Package,Library,CenterPointX,CenterPointY,Rotation\n" );

                    for ( i = 0; i < counter; i++ ) {
                        printf ( "%s,%s,%s,%s,%s,%s,%s\n", Ename[i], Evalue[i], Epackagename[i], ElibrarySource[i], EpartsX[i], EpartsY[i], Eangle[i] );
                    }

                    printf ( "\n\n" );
                }

                // REEL Assignment
                real offsetx, offsety;
                string comment;
                int ReelNo_G;
                printf ( "#Feeder,Feeder ID,Type,Nozzle,X,Y,Angle,Footprint,Value,Pick height,Pick delay,Placement height,Placement delay,Vacuum detection,Vacuum value,Vision alignment,Speed,\n" );

                for ( j = 1; j <= MAXREEL ; j++ ) {

                    int id, inc = 0;

                    offsetx = ReelOffSetX[j];
                    offsety = ReelOffSetY[j];

                    // will skip reels with no offset.
                    // lets keep them, if we're using phantom reels
                    // ok changed my mind again, remove them if offsetx/y or name is 0/empty just " "

                    if ( ( strlen ( Reel[j] ) == 1 & strstr ( Reel[j], " " ) == 0 ) ) {
                        continue;
                    }

                    if ( ( ( offsetx == 0 & offsety == 0 ) | strlen ( Reel[j] ) == 0 )  ) {
                        continue;
                    }

                    //comment = Reel[j];
                    //printf ( "65535,1,%d,%.2f,%.2f,%s,\n", j, offsetx, offsety, comment );

                    id = 0;

                    // special feeder(this crashed older versions of neoden software, have to look into it
                    if ( j >= SPECIALREEL ) {
                        id = 1;
                    }

                    //special feeders have a different format.

                    //#Feeder, Feeder ID, Type, Nozzle,    X,      Y, Angle, Footprint, Value  , Pick height, Pick delay, Place Height, Place Delay, Vacuum Discard,  Threshold, Vision Alignment, Speed,
                    //stack,   98,          1,    1 ,  92.27, 226.88, 0.00,     0805,   special,-1.00,            0,           0.00,         0,            No,            -40,       1,                50,

                    //continued
                    // columns, rows, right top x , right top y, startx, starty,   skip, size correct,  thresholds for nozzles 1-4
                    // 9,        8,   162.27,      206.88,         3,       4,        No,      No,       -40,-40,-40,-40,

                    // Nozzle can be a list so if its 1, its 1, if its 1 and 4, its 14, all would be 1234

                    // calculate an overide move speed
                    int move_speed = ReelMoveSpeed[j];

                    // can't be zero.
                    if ( board_move_override == 0 ) {
                        board_move_override = 1;
                    }

                    if ( board_move_override != 100 ) {

                        real temp;

                        temp = ( move_speed / 100.0 ) * board_move_override;

                        //round it, the neoden will override anything that isn't in steps of 10
                        move_speed = round_and_clamp ( temp, 10, 100 );
                    }

                    int nozzleid;
                    // converts to a number, since eagle combo boxes don't work without a first entry which we have as -
                    nozzleid = strtol ( nozzleCombo[ReelHead[j]] );

                    if ( j < SPECIALREEL ) {
                        printf ( "stack,%d,%d,%d," +
                                 "%.2f,%.2f,%.2f," +
                                 "%s,%s," +

                                 "%.2f,%d,%.2f,%d," +
                                 "%s,%d,%d," +
                                 "%d,%d,%d,%d,%s,%s," +
                                 "%s,%s,%s,%s,\n",

                                 j, id, nozzleid,
                                 ReelOffSetX[j], ReelOffSetY[j], ReelPickAngle[j],
                                 ReelFootPrint[j], Reel[j],

                                 ReelHeight[j], ReelPickDelay[j], ReelPlaceHeight[j], ReelPlaceDelay[j],

                                 ReelVacuumDetection[j] ? "Yes" : "No", ReelVacuumValue[j], ReelVisionAlignment[j],

                                 move_speed, ReelRate[j], ReelFeedStrength[j], ReelPeelStrength[j], ReelSkip[j] ? "Yes" : "No", ReelSizeCorrect[j] ? "Yes" : "No",

                                 ComboThresholds[Nozzle1Thresholds[j]], ComboThresholds[Nozzle2Thresholds[j]], ComboThresholds[Nozzle3Thresholds[j]], ComboThresholds[Nozzle4Thresholds[j]]
                               );

                    } else {

                        //continued
                        // columns, rows, right top x , right top y, startx, starty,   skip, size correct,  thresholds for nozzles 1-4
                        // 9,        8,   162.27,      206.88,         3,       4,        No,      No,       -40,-40,-40,-40,

                        printf ( "stack,%d,%d,%d," +
                                 "%.2f,%.2f,%.2f," +
                                 "%s,%s," +

                                 "%.2f,%d,%.2f,%d," +

                                 "%s,%d,%d," +
                                 "%d," +
                                 //changes
                                 "%d,%d,%.2f,%.2f,%d,%d," +
                                 // skip/correct
                                 "%s,%s," +

                                 //nozzles
                                 "%s,%s,%s,%s,\n",

                                 j, id, nozzleid,
                                 ReelOffSetX[j], ReelOffSetY[j], ReelPickAngle[j],
                                 ReelFootPrint[j], Reel[j],

                                 ReelHeight[j], ReelPickDelay[j], ReelPlaceHeight[j], ReelPlaceDelay[j],

                                 ReelVacuumDetection[j] ? "Yes" : "No", ReelVacuumValue[j], ReelVisionAlignment[j],

                                 move_speed,

                                 //     ReelRate[j], ReelFeedStrength[j], ReelPeelStrength[j], ReelSkip[j] ? "Yes" : "No", ReelSizeCorrect[j] ? "Yes" : "No",
                                 //changes
                                 trayColumns[j],						//%d 17
                                 trayRows[j],							//%d 18
                                 trayRightTopX[j],						//%f 19
                                 trayRightTopY[j],						//%f 20
                                 trayStartX[j], 						//%d 21
                                 trayStartY[j],							//%d 22

                                 // restarts
                                 ReelSkip[j] ? "Yes" : "No", ReelSizeCorrect[j] ? "Yes" : "No",

                                 ComboThresholds[Nozzle1Thresholds[j]], ComboThresholds[Nozzle2Thresholds[j]], ComboThresholds[Nozzle3Thresholds[j]], ComboThresholds[Nozzle4Thresholds[j]]
                               );
                    }

                    /////////////////
                }


                // find first component XY, add adjusted board offset if any, we scan the list of components since this needs to be known before listing the components out
                real first_x = get_first_x() + board_offset_x;
                real first_y = get_first_y() + board_offset_y;

                // pcb, manual feed, mag fixtured, something,something, detect x, detect y,
                printf ( "pcb,Manual,Lock,100,100,350,150,Front,10,10,0,\n" );

                //fiducial settings

                // how many were found
                int number_of_fiducials = scan_for_fiducials();


                printf ( "test,No,\n" );

                // are there any fiducials?
                if ( number_of_fiducials ) {

                    // list of fiducials @todo,scan list of components with FID in the name ?
                    // mark, Mirror/Whole, Auto/Manual
                    // Auto/Manual = PCB Mark Settings ( Manual checkbox)
                    // Mirror/Whole = Panelised or Single
                    printf ( "mark,Whole,Auto," );

                    for ( int fid = 0; fid < number_of_fiducials; fid++ ) {
                        printf ( "%.3f,%.3f,", g_fiducial_x[fid] + board_offset_x, g_fiducial_y[fid] + board_offset_y );
                    }

                    //terminate line
                    printf ( "\n" );


                    // one per fiducial
                    // markext, index, min,max,light source 1 =inner  (outer ) , brightness 0 = auto  (25/60/75/100/150/200/250/300)
                    for ( fid = 0; fid < number_of_fiducials; fid++ ) {
                        printf ( "markext,%d,0.8,3,1,0,\n", fid );
                    }
                }

                //  rows, cols, left bottom(x.y),...... last one is board rotation
                // mirror_create,1,1,259.14,338.93,0,0,0,0,-0.187445,
                printf ( "mirror_create,1,1,%.3f,%.3f,0,0,0,0,%f,\n", first_x, first_y, g_board_rotation );



                // panel list

                // x,y, rotation
                printf ( "mirror,%.3f,%.3f,0,No,\n", first_x, first_y );

                if ( ( nBoardsinX != 0 ) || ( nBoardsinY != 0 ) ) {
                    // todo: Multiple boards

                }

                // Part placement setup
                // Part placement
                // Part     Pickup  Stack   X       Y       Rotation    Height  Skip    Reference   Comment
                // number   head
                // 1        1       1       4.00    22.00   -45         1       0       LED7    LED-805
                // 2        1       1       4.00    19.00   -45         1       0       LED8    LED-805
                // 3        1       1       4.00    16.00   -45         1       0       LED9    LED-805

                printf ( "#Chip,Feeder ID,Nozzle,Name,Value,Footprint,X,Y,Rotation,Skip\n" );

                B.elements ( E ) {
                    int wasSmd,
                        xmax = -2147483648,
                        xmin = 2147483647,
                        ymax = xmax,
                        ymin = xmin;
                    string smdlayer = "";
                    real angle = 0;

                    wasSmd = 0;

                    E.package.contacts ( C ) {

                        if ( C.smd && C.smd.layer == 1 ) {
                            smdlayer = "Top";
                            wasSmd = 1;
                        }

                        else {
                            if ( C.smd && C.smd.layer == 16 ) {
                                smdlayer = "Bottom";
                                wasSmd = 1;
                            }

                            else {
                                smdlayer = "???";
                                wasSmd = 1;
                            }
                        }

                        if ( C.x > xmax ) { xmax = C.x; }

                        if ( C.y > ymax ) { ymax = C.y; }

                        if ( C.x < xmin ) { xmin = C.x; }

                        if ( C.y < ymin ) { ymin = C.y; }

                    }

                    if ( wasSmd ) {

                        real partsheight;
                        int skip, head;
                        int stack;
                        found = 0;
                        int i_got_it = 0;
                        int E_ptr;
                        int Counterx;
                        stack = 99;

                        if ( csv == 0 ) {
                            Counterx = TopCounter;
                        }

                        else {
                            Counterx = BottomCounter;
                        }

                        if ( debug == 1 ) {
                            for ( j = 0; j < Counterx; j++ ) {
                                printf ( "Value of CT_ReelNo[%d]=%d Selected: %s\n", j, CT_ReelNo[j], Reel[CT_ReelNo[j]] );
                            }
                        }

                        for ( j = 0; j < Counterx; j++ ) {

                            string a[];
                            int i_got_it = 0;

                            if ( csv == 0 ) {
                                n = strsplit ( a, components_Top[j], ',' );
                            }

                            else {
                                n = strsplit ( a, components_Bottom[j], ',' );
                            }

                            for ( l = 0; l < n; l++ ) {
                                if ( alltrim ( E.name ) == alltrim ( a[l] ) ) {
                                    i_got_it = 1;
                                    break;
                                }

                                else {
                                    i_got_it = 0;
                                }
                            }

                            if ( debug == 1 ) {
                                printf ( "Looking for %s seen component_Top[%d]= %s\n", E.name, j, components_Top[j] );

                            }

                            if ( i_got_it == 1 ) {
                                if ( csv == 0 ) {
                                    if ( debug == 2 ) {
                                        printf ( "Found component_Top[%d]= %s\n", j, components_Top[j] );
                                    }

                                    if ( CT_ReelNo[j] != 0 ) {
                                        stack = CT_ReelNo[j] - 1; // contains reel#
                                    }

                                    else {
                                        stack = 99;
                                    }

                                    partsheight = CT_Eheight[j];
                                    skip = CT_Skip[j];
                                    head = CT_Ehead[j];

                                }

                                else {
                                    if ( debug == 2 ) {
                                        printf ( "Found component_Bottom[%d]= %s\n", j, components_Bottom[j] );
                                    }

                                    if ( CB_ReelNo[j] != 0 ) {
                                        stack = CB_ReelNo[j] - 1; // contains reel#
                                    }

                                    else {
                                        stack = 99;
                                    }

                                    partsheight = CB_Eheight[j];
                                    skip = CB_Skip[j];
                                    head = CB_Ehead[j];

                                }

                                if ( debug == 2 ) {
                                    printf ( "Got it: stack= %d, height= %.2f, skip= %d, head = %d\n", stack, partsheight, skip, head );
                                }

                                i_got_it = 0;
                                break;
                            }
                        }

                        real PartsRotation = E.angle ;

                        if ( E.angle <= 180 ) {
                            angle = E.angle;
                        }

                        else {
                            angle = E.angle - 360;
                        }



                        if ( stack != 99 ) {
							if ( csv == 0 ) {
								printf ( "comp,%d,%d,%s,%s,%s,%.2f,%.2f,%.0f,%s,\n",
										stack + 1, head, E.name, E.value, E.package.name,
										u2mm ( ( xmin + xmax ) / 2 ) + board_offset_x,
										u2mm ( ( ymin + ymax ) / 2 ) + board_offset_y,
										angle,
										skip ? "Yes" : "No"
									);
							}
							else {
								printf ( "comp,%d,%d,%s,%s,%s,%.2f,%.2f,%.0f,%s,\n",
										stack + 1, head, E.name, E.value, E.package.name,
										boardWidth - u2mm ( ( xmin + xmax ) / 2 ) + board_offset_x,
										u2mm ( ( ymin + ymax ) / 2 ) + board_offset_y,
										angle,
										skip ? "Yes" : "No"
									);
							}
                        }

                        else {
                            // no assigned stack
                            if ( debug == 1 ) {
                                printf ( "%d,%d,,%.2f,%.2f,%.0f,%.2f,%d,%s,%s-%s\n", line++, head, u2mm ( ( xmin + xmax ) / 2 ) + board_offset_x, u2mm ( ( ymin + ymax ) / 2 ) + board_offset_y, angle, partsheight, skip, E.name, E.value, E.package.name );
                            }
                        }
                    }
                }
            }
        }

        // @todo check/fix this
        output ( StackFname ) {

            for ( j = 0; j < TopCounter; j++ ) {
                printf ( "[TOP]|%s|%d|%d|%.2f|%d|%d\n", components_Top[j], CT_ReelNo[j], CT_Ehead[j], CT_Eheight[j], CT_Skip[j], CT_Rate[j] );
            }

            for ( j = 0; j < BottomCounter; j++ ) {
                printf ( "[BOTTOM]|%s|%d|%d|%.2f|%d|%d\n", components_Bottom[j], CB_ReelNo[j], CB_Ehead[j], CB_Eheight[j], CB_Skip[j], CB_Rate[j] );

            }

            for ( j = 0; j < MidCounter; j++ ) {
                printf ( "[???]|%s|%d|%d|%.2f|%d|%d\n", components_Mid[j], CM_ReelNo[j], CM_Ehead[j], CM_Eheight[j], CM_Skip[j], CM_Rate[j] );

            }

            for ( j = 0; j < MAXREEL; j++ ) {

                write_reel_line ( j + 1 );
            }
        }

        // csv exported
        if ( fileerror() ) {
            dlgMessageBox ( ";Files are Open. CSV export Failed. \n", "&OK" );
            exit ( 1 );
        }

        else {
            // seems unecessary
            // dlgMessageBox ( ";CSV and PnP file export Success: \n " + csvnametop + "\n" + csvnamebottom + "\n" + StackFname + "\n", "&OK" );
        }

    }
}

else
{
    int ok = dlgMessageBox ( "!Board  must be open", "&OK" );

}   //  (project.board) project.board(B)

//dlgMessageBox("Value of Result"+ Num2Str(Result), "&OK");
exit ( 0 );

